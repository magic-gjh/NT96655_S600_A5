//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndMovieRes.c"
#include "UIFlow.h"
#include "Audio.h"
#include "UIWndNotUse.h"
#include "ide.h" 
#include "md_api.h"
#include "IPL_CBMsg.h"
#include "FileSysTsk.h"
#include "MediaRecAPI.h"
#include "IPL_Ctrl.h" // Isiah, implement YUV merge mode of recording func.
#include "Gsensor.h"
#include "UIFlowWndHome.h"
#include "MenuCommonItem.h"
#if USE_FILEDB
#include "FileDB.h"
#include "namerule_fileDB.h"
#endif
#define __MODULE__          UIFlowWndMovie
//#define __DBGLVL__ 0        //OFF mode, show nothing
//#define __DBGLVL__ 1        //ERROR mode, show err, wrn only
#define __DBGLVL__ 2        //TRACE mode, show err, wrn, ind, msg and func and ind, msg and func can be filtering by __DBGFLT__ settings
#define __DBGFLT__ "*"      //*=All
#include "DebugModule.h"
#include "PipView.h"
#include "UIConfig.h"
#include "Rtc.h"
#include "Adc.h"
#include "UsbDevDef.h"
#include "UIConfig.h"
#include "UIInfo.h"
#include "UICfgDefault.h"
#include "PipView.h"
//---------------------UIFlowWndMovieCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie)
CTRL_LIST_ITEM(UIFlowWndMovie_RecPanel)
CTRL_LIST_ITEM(UIFlowWndMovie_Resolution)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_battery)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Return)
CTRL_LIST_ITEM(UIFlowWndMovie_Radar_Mode)
CTRL_LIST_ITEM(UIFlowWndMovie_Radar_Vol)
CTRL_LIST_ITEM(UIFlowWndMovie_Radar_Vol_Lvl)
CTRL_LIST_ITEM(UIFlowWndMovie_Angle)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_GPS)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_Speed_limit_Panel)
CTRL_LIST_ITEM(UIFlowWndMovie_Distance)
CTRL_LIST_ITEM(UIFlowWndMovie_CurSpeed)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Storage)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_Radar_Waring)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_Radar_SingalLvl)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_RD_EYE)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_RD_ON)
CTRL_LIST_ITEM(UIFlowWndMovie_TXT_REC)
CTRL_LIST_ITEM(UIFlowWndMovie_GPSDB)
CTRL_LIST_ITEM(UIFlowWndMovie_Audio)
CTRL_LIST_ITEM(UIFlowWndMovie_Lock)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_REC)
CTRL_LIST_END

//----------------------UIFlowWndMovieCtrl Event---------------------------
INT32 UIFlowWndMovie_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOverTime(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieWrError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnRAWEncOK(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnPreviewStable(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACPlug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACUnplug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnCustom1(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_GsensorTrig(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_EdogMessage(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_TP(VControl *, UINT32, UINT32 *);



EVENT_BEGIN(UIFlowWndMovie)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndMovie_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndMovie_OnClose)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndMovie_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndMovie_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndMovie_OnKeyDown)
EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndMovie_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndMovie_OnKeyRight)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndMovie_OnChildClose) 
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndMovie_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndMovie_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndMovie_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndMovie_OnKeyPlayBack)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndMovie_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW,UIFlowWndMovie_OnBatteryLow)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndMovie_OnKeyMode)
//EVENT_ITEM(NVTEVT_CB_MOVIE_REC_FINISH,UIFlowWndMovie_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_ONE_SEC,UIFlowWndMovie_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_OVERTIME,UIFlowWndMovie_OnOverTime) // the same handling as storage full (may need to show special message)
EVENT_ITEM(NVTEVT_CB_MOVIE_FULL,UIFlowWndMovie_OnMovieFull)
EVENT_ITEM(NVTEVT_CB_MOVIE_WR_ERROR,UIFlowWndMovie_OnMovieWrError)
EVENT_ITEM(NVTEVT_CB_MOVIE_SLOW,UIFlowWndMovie_OnStorageSlow)
EVENT_ITEM(NVTEVT_CB_MOVIE_LOOPREC_FULL,UIFlowWndMovie_OnLoopRecFull)
EVENT_ITEM(NVTEVT_CB_RAWENC_OK,UIFlowWndMovie_OnRAWEncOK)
//EVENT_ITEM(IPL_CBMSG_PREVIEWSTABLE,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CALLBACK,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG,UIFlowWndMovie_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_ZOOM,UIFlowWndMovie_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_STORAGE_INIT,UIFlowWndMovie_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndMovie_OnStorageChange)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndMovie_OnTimer)
EVENT_ITEM(NVTEVT_AC_Plug,UIFlowWndMovie_OnACPlug)
EVENT_ITEM(NVTEVT_AC_UnPlug,UIFlowWndMovie_OnACUnplug)
EVENT_ITEM(NVTEVT_KEY_CUSTOM1,UIFlowWndMovie_OnCustom1)
EVENT_ITEM(NVTEVT_GSENSOR_TRIG,UIFlowWndMovie_GsensorTrig)
EVENT_ITEM(NVTEVT_EDOG_MESSAGE,UIFlowWndMovie_EdogMessage)
EVENT_ITEM(NVTEVT_KEY_TP,UIFlowWndMovie_TP)

EVENT_END

// Isiah, implement YUV merge mode of recording func.
extern void Movie_IPLChangeCB(UINT32 mode, UINT32 param);

// Movie mode key mask
#define MOVIE_KEY_PRESS_MASK        (FLGKEY_KEY_MASK_DEFAULT)
#define MOVIE_KEY_RELEASE_MASK      (FLGKEY_UP | FLGKEY_DOWN)
#define MOVIE_KEY_CONTINUE_MASK     (FLGKEY_UP | FLGKEY_DOWN | FLGKEY_ENTER | FLGKEY_MODE)
#define MOVIERECORD_KEY_PRESS_MASK  (FLGKEY_UP | FLGKEY_DOWN | FLGKEY_ENTER | FLGKEY_MODE)
//-----------------------------------------------------------------------------------------
BOOL    g_uiRecordIngMotionDet = FALSE;
static UINT32  gUIMotionDetTimerID = NULL_TIMER;
static UINT32  g_uiDateTimerID = NULL_TIMER;
static UINT32 g_uiMaskKeyPress      = MOVIE_KEY_PRESS_MASK;
static UINT32 g_uiMaskKeyRelease    = MOVIE_KEY_RELEASE_MASK;
//static UINT32 g_uiMaskKeyContinue   = MOVIE_KEY_CONTINUE_MASK;
static volatile BOOL g_bRedLEDOn = FALSE;
static volatile BOOL g_ACPlug = FALSE;
static volatile BOOL g_PreviewStable = FALSE;
static volatile BOOL g_PreviewStable_Record = FALSE;
BOOL g_bSpeLockFun = FALSE;
_ALIGNED(4)  GPSDATA gpsdata={0};
BOOL g_bgsensor = FALSE;

static UINT32 ShowGPSSignalStepCnt = 0;
static UINT32 ShowGPSSignalStepCnt_last = 0;
static UINT32 ShowGPSSignalTimeCnt = 0;

static BOOL IsNeedToShowGPSSignal = FALSE;

extern int SX_TIMER_DET_GSENSOR_ID;

UINT32 EdogVolumeIndex;
UINT32 EdogMuteIndex;
UINT32 EdogDriveModeIndex ;
UINT32 EdogRadarIndex;
UINT32 EdogOverSpeedIndex;
UINT32 EdogSpeedOffsetIndex;
UINT32 EdogBroadCastIndex;

UINT32 EdogDataVersion[2];
UINT32 EdogFWVersion;

static BOOL gbEdogPhaseMessageEn=TRUE;
static BOOL gbEdogUpateGPSTimeFlag=FALSE;
BOOL gbGetEdogFWVersion=FALSE;
BOOL gbQuickMute=FALSE;
static BOOL gbUpdteGPSTime=FALSE;
extern RDINFO RDInfo;



void Refresh_Screen_Display(void)
{
    GxDisplay_Set(LAYER_OSD1, LAYER_STATE_ENABLE, 0); //turn off OSD1
    GxDisplay_Set(LAYER_OSD2, LAYER_STATE_ENABLE, 0); //turn off OSD2
    GxDisplay_Set(LAYER_OSD1, LAYER_STATE_ENABLE, 1); //turn off OSD1
    GxDisplay_Set(LAYER_OSD2, LAYER_STATE_ENABLE, 1); //turn off OSD2
}

#define KEY_ADC_DOWN   (174)
#define KEY_ADC_RANG     (25)
BOOL UIFlowMovie_CheckUpdateLogo(void)
{
  BOOL ret = FALSE;
  UINT32 uiADCValue;
  uiADCValue = adc_readData(ADC_CHANNEL_1);
  if((uiADCValue>(KEY_ADC_DOWN-KEY_ADC_RANG))&&(uiADCValue<(KEY_ADC_DOWN+KEY_ADC_RANG)))
  {
		return TRUE;
  }
  return ret;
}

void FlowMovie_SetUpdateGPSTimeFlag(BOOL Flag)
{
	gbEdogUpateGPSTimeFlag=Flag;
}
void FlowMovie_UpdateGPSTime(EDOG_INFO *pEdogInfo)
{
 	UINT32 year,month,day;
 	UINT32 hour,min,second,week;
	if(gbEdogUpateGPSTimeFlag==FALSE)
	{
		year=pEdogInfo->CommandT.Year+2000;
		month=pEdogInfo->CommandT.Month;
		day=pEdogInfo->CommandT.Day;		
		hour=pEdogInfo->CommandT.Hour;		
		min=pEdogInfo->CommandT.Minute;		
		second=pEdogInfo->CommandT.Second;	
		week=pEdogInfo->CommandT.Week;
		if((year<2000)||(year>2255))
			return;
		if((month<1)||(month>12))
			return;		
		if((day<1)||(day>31))
			return;		
		if((hour<1)||(hour>23))
			return;		
		if((min<1)||(min>59))
			return;		
		if((second<1)||(second>59))
			return;			
		gbEdogUpateGPSTimeFlag=TRUE;
		rtc_setDate(year, month, day);
		rtc_setTime(hour, min, second);
		rtc_triggerCSET();		
		
    		//UxState_SetData(&UIFlowWndMovie_StatusTXT_WeekCtrl,STATE_CURITEM,week);
		//UxCtrl_SetShow(&UIFlowWndMovie_StatusTXT_WeekCtrl, TRUE);
	}
}

void FlowMovie_UpdateEdogMenuInfo(EDOG_INFO *pEdogInfo)
{
       UINT32 EdogMute;
	UINT32 SpeedLimit;
	
       debug_msg("UIFlowwnd movie get P command..\r\n");
	if(gbGetEdogFWVersion==FALSE)
	{
		gbGetEdogFWVersion=TRUE;
		EdogDataVersion[0]=pEdogInfo->CommandP.DataVersion1;
		EdogDataVersion[1]=pEdogInfo->CommandP.DataVersion2;
		EdogFWVersion =pEdogInfo->CommandP.FWVersion;
		EdogVolumeIndex=pEdogInfo->CommandP.Volume;
		EdogMuteIndex=pEdogInfo->CommandP.RadarMuteSetting;
		EdogDriveModeIndex =pEdogInfo->CommandP.DriveMode;
		EdogRadarIndex =pEdogInfo->CommandP.RadarSensitivity;
		EdogOverSpeedIndex =pEdogInfo->CommandP.OverSpeedSetting;
		EdogSpeedOffsetIndex =pEdogInfo->CommandP.SpeedOffset;
		EdogBroadCastIndex = pEdogInfo->CommandP.VoiceSetting;	  			

		SysSetFlag(FL_EDOGVOLUME,EdogVolumeIndex);//  1, 2, 3, 4,
		
		if(EdogMuteIndex!=0)
		EdogMute=(EdogMuteIndex/10-1);	
		SysSetFlag(FL_EDOGMUTE,	EdogMute); //0,20,30,40,50...	
		
		if(EdogDriveModeIndex!=0)
		EdogDriveModeIndex-=1;			
		SysSetFlag(FL_EDOGDRIVEMODE, EdogDriveModeIndex);	//  1,2

		SysSetFlag(FL_EDOGSENSITY, EdogRadarIndex);//0,1,2,3		

		if(EdogOverSpeedIndex!=0)
		SpeedLimit=(EdogOverSpeedIndex/10-3);				
		SysSetFlag(FL_EDOGSPEED_LIMIT, SpeedLimit);	//0,40,50,60,70,80,90...

		if((EdogSpeedOffsetIndex&0xF0)==0xF0)
		{
			EdogSpeedOffsetIndex=0XFA-EdogSpeedOffsetIndex;
		}
		else
		{
			EdogSpeedOffsetIndex+=10;
		}
		SysSetFlag(FL_EDOGSPEED_ADJUST,EdogSpeedOffsetIndex);	

		if(EdogBroadCastIndex!=0)
		EdogBroadCastIndex-=1;	
		SysSetFlag(FL_EDOGBROADCAST,EdogBroadCastIndex);		
 debug_msg("default --2--:%d,%d,%d,%d,%d,%d,%d\r\n",EdogVolumeIndex,EdogMute,EdogDriveModeIndex,EdogMute,SpeedLimit,EdogSpeedOffsetIndex,EdogBroadCastIndex);			  			
	}
}

#if (UI_STYLE==UI_STYLE_DRIVER)
extern BOOL m_bACPlug;
#endif

void UIFlowwndMovieUpdateGPSTime()
{			
       UINT32 day = 0, month = 0, year = 0, hour = 0, min = 0, sec = 0;
	UINT8	uiTimeZone = 0;
       RTC_DATE rtcDate;
       UINT32 Days;
       
	//if (uiPreGPSStatus != GPSStatus)
	{
		debug_msg("###Set date time by GPS (Greenwich)(%04d/%d/%d,%d:%d:%d).    ###\r\n",RMCInfo.Year, RMCInfo.Month, RMCInfo.Day, RMCInfo.Hour, RMCInfo.Minute, RMCInfo.Second);
		day = RMCInfo.Day;
		month = RMCInfo.Month;
		year = RMCInfo.Year;
		hour = RMCInfo.Hour;
		min = RMCInfo.Minute;
		sec = RMCInfo.Second;
        
              rtcDate=rtc_getDate();
		//rtcDate.s.year = year+2000;
		//rtcDate.s.month = month;
		//rtcDate.s.day = day;
		Days = rtc_convertDate2Days(rtcDate);
				
		uiTimeZone = TIME_ZONE_GMT8;//SysGetFlag(FL_AUTO_UPDATE_TIME);//(FL_TIME_ZONE);
		switch (uiTimeZone)
		{
			case TIME_ZONE_GMTM12:
			case TIME_ZONE_GMTM11:
			case TIME_ZONE_GMTM10:
			case TIME_ZONE_GMTM9:
			case TIME_ZONE_GMTM8:
			case TIME_ZONE_GMTM7:
			case TIME_ZONE_GMTM6:
			case TIME_ZONE_GMTM5:
				if(hour<(13-uiTimeZone))
				{
					hour=24+hour-(13-uiTimeZone);
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=(13-uiTimeZone);
				}
				break;									
			case TIME_ZONE_GMTM4:
				if(hour<(13-uiTimeZone+1))
				{
					hour=24+hour-(13-uiTimeZone+1);
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=(13-uiTimeZone+1);
				}
				break;									
			case TIME_ZONE_GMTM3:
			case TIME_ZONE_GMTM2:
			case TIME_ZONE_GMTM1:
				
				if(hour<(13-uiTimeZone+2))
				{
					hour=24+hour-(13-uiTimeZone+2);
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=(13-uiTimeZone+2);
				}
				break;
			case TIME_ZONE_GMTM430:
				if(min<30)
				{
				       if(hour>0){
					hour-=1;
					min+=30;}
					  else{
					Days-=1;
					hour=23;
					min+=30;}
					
				}
				else
				{
					min-=30;
				}
				if(hour<4)
				{
					hour=24+hour-4;
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=4;
				}									
				break;
			case TIME_ZONE_GMTM330:
				if(min<30)
				{
				       if(hour>0){
					hour-=1;
					min+=30;}
					  else{
					Days-=1;
					hour=23;
					min+=30;}
					
				}
				else
				{
					min-=30;
				}
				if(hour<3)
				{
					hour=24+hour-3;
					Days-=1;
					rtcDate=rtc_convertDays2Date(Days);
					year=rtcDate.s.year;
					month=rtcDate.s.month;
					day=rtcDate.s.day;										
				}
				else
				{
					hour-=3;
				}									
				break;									
			case TIME_ZONE_GMT1:
				hour += 1;
				break;
			case TIME_ZONE_GMT2:
				hour += 2;
				break;
			case TIME_ZONE_GMT3:
				hour += 3;
				break;							
			case TIME_ZONE_GMT330:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 4;
				}
				else
				{
					hour += 3;
				}
				break;
			case TIME_ZONE_GMT4:
				hour += 4;
				break;							
			case TIME_ZONE_GMT430:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 5;
				}
				else
				{
					hour += 4;
				}
				break;
			case TIME_ZONE_GMT5:
				hour += 5;
				break;
			case TIME_ZONE_GMT530:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 6;
				}
				else
				{
					hour += 5;
				}
				break;											
			case TIME_ZONE_GMT545:
				min += 45;
				if (min >= 60)
				{
					min -= 60;
					hour += 6;
				}
				else
				{
					hour += 5;
				}
				break;
			case TIME_ZONE_GMT6:
				hour += 6;
				break;
			case TIME_ZONE_GMT630:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 7;
				}
				else
				{
					hour += 6;
				}
				break;										
			case TIME_ZONE_GMT7:
				hour += 7;
				break;
			case TIME_ZONE_GMT8:
				hour += 8;
				break;
			case TIME_ZONE_GMT9:
				hour += 9;
				break;
			case TIME_ZONE_GMT930:
				min += 30;
				if (min >= 60)
				{
					min -= 60;
					hour += 10;
				}
				else
				{
					hour += 9;
				}
				break;
			case TIME_ZONE_GMT10:
				hour += 10;
				break;
			case TIME_ZONE_GMT11:
				hour += 11;
				break;
			case TIME_ZONE_GMT12:
				hour += 12;
				break;		
			case TIME_ZONE_GMT13:
				hour += 13;
				break;										
			default:
				break;									
		}
		if (hour >= 24)
		{
			hour -= 24;
			day ++;
			if ((month == 4) || (month == 6) || (month == 9) || (month == 11))
			{
				if (day > 30)
				{
					day = 1;
					month ++;
				}
			}
			else if ((month == 1) || (month == 3) || (month == 5) || (month == 7) || (month == 8) || (month == 10))
			{
				if (day > 31)
				{
					day = 1;
					month ++;
				}
			}
			else if (month == 12)
			{
				if (day > 31)
				{
					year ++;
					day = 1;
					month = 1;
				}
			}
			else if (month == 2)
			{
				if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0))
				{
					if (day > 29)
					{
						month ++;
						day = 1;
					}
				}
				else
				{
					if (day > 28)
					{
						month ++;
						day = 1;
					}
				}
			}
		}		
		debug_msg("###Set date time by GPS (BeiJing)(%04d/%d/%d,%d:%d:%d).    ###\r\n",year, month, day, hour, min, sec);
		//rtc_setDate(year+2000, month, day);
		rtc_setDate(year, month, day);
	       rtc_setTime(hour, min, sec);
	       rtc_triggerCSET();  
	}
}

BOOL UIFlowWndMovie_IsGsensorTrig(void)
{
	return g_bgsensor;
}
void UIFlowWndMovie_SetGsensorTrigFlag(BOOL En)
{
	g_bgsensor=En;
}
#if (USE_FILEDB==DISABLE)
static void UIFlowWndMovie_DeleteEmptyFolder(void)
{
 SDCFDIRINFO dirinfo;
 char   path[DCF_FULL_FILE_PATH_LEN];
 UINT32 uiMaxFolderID,uiPrevMaxFolderID;
 UINT32 uiStrlen;
 BOOL ret;


    uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);
    // check if folder has file
    ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);
    if (ret)
    {
        while (dirinfo.uiNumOfDcfObj==0)
        {
            DCF_GetDirPath(uiMaxFolderID,path);
            uiStrlen = strlen(path);
            path[uiStrlen-1] = '\0';
            if (FileSys_DeleteDir(path) != FST_STA_OK)
            {
                debug_msg("FileSys_DeleteDir failed\r\n");
            }

            DCF_Refresh();

            uiPrevMaxFolderID = uiMaxFolderID;
            // search another Max Empty folder ID
            uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);

            // break if getting max folder id is always same
            if (uiPrevMaxFolderID == uiMaxFolderID)
                break;
            // check if folder has file
            ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);

            if (ret==FALSE)
              break;
        }
    }
}
#endif

#if (USE_FILEDB==ENABLE)
static void UIFlowWndMovie_OnDeleteOld(void)
{
 UINT32 filenum=0,sec=0;
 UINT32 index = 0;
 PFILEDB_FILE_ATTR  pfile; 

    // delete old file and start recording again
    if (SysGetFlag(FL_MOVIE_CYCLIC_REC)!=MOVIE_CYCLICREC_OFF)
    {
        switch(SysGetFlag(FL_MOVIE_CYCLIC_REC))
        {
          case MOVIE_CYCLICREC_3MIN:
             sec=180;
          break;
          case MOVIE_CYCLICREC_5MIN:
             sec=300;
          break;
          case MOVIE_CYCLICREC_10MIN:
             sec=600;
          break;
        }

        FileDB_Refresh(0);
        filenum = FileDB_GetTotalFileNum(0);
        while (filenum--)
        {
            pfile = FileDB_SearhFile2(0,index);
            if (!M_IsReadOnly(pfile->attrib))
            {
                if (UIMovRecObj_GetData(RECMOVIE_MAXSECOND)>(sec+10))
                    break;

                FileSys_DeleteFile(pfile->filePath);
                FileDB_DeleteFile(0,index);
            }
            index++;
        }
    }
}
#endif

static void Filesys_dirCB(FIND_DATA *findDir, BOOL *bContinue, UINT16 *cLongname, UINT32 Param)
{
    *bContinue = TRUE;
}
INT32 UIFlowWndMovie_OnExeRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiKeyAct;
    UINT32 uiState;
    BOOL   CheckStorageErr = FALSE;


    // flush key event first
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

    // if HDMI is inserted, 128MB buffer is not enough for movie recording
    if (KeyScan_GetPlugDev() == PLUG_HDMI)
    {
        return NVTEVT_CONSUME;
    }

    #if (_DUAL_CARD_FUNC_ == ENABLE)
    if ((UI_GetData(FL_CardStatus) == CARD_REMOVED) && (UI_GetData(FL_Card2Status) == CARD_REMOVED))
    #else
    if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
    #endif
    {
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
        return NVTEVT_CONSUME;
    }

    if (paramNum>=3)
    {
        uiState = paramArray[2];
    } else {
        uiState = 0;
    }

    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
            // return directly if dual display is on and 2nd display is HDMI
            // this cause is buffer limitation
            if (SysGetFlag(FL_DualDisp) == DUALDISP_ONBOTH&& IsDualHDMIPlugIn())
            {
                return NVTEVT_CONSUME;
            }
            if (MediaRec_GetStatus() == MEDIAREC_STATUS_OPENED_NOT_RECORD)
            {
                gMovData.State= MOV_ST_REC;
                //#NT#2013/1/28#Philex Lin - begin
                // fix bug that can't record in cyclic and card full case
                if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
                {
                    CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                } else {
                    #if USE_FILEDB
                    if (UI_GetData(FL_IsUseFileDB))
                    {
                       if (FileSys_ScanDir("A:\\DCIM\\",Filesys_dirCB,FALSE)==FST_STA_OK)
                       {
                           CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                       } else {
                          CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                       }
                    }
                    #else
                    CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                    #endif
                }
                if (CheckStorageErr == TRUE)
                //#NT#2013/1/28#Philex Lin - end
                {
                    gMovData.State= MOV_ST_WARNING_MENU;
                    gMovData.SysTimeCount = 0;
                    return NVTEVT_CONSUME;
                }
                if(GetBatteryLevel() == BATTERY_EXHAUSTED)
                {
                    debug_err(("UIFlowWndMovie_OnExeRecord: Battery is too low!\r\n"));
                    return NVTEVT_CONSUME;
                }
                if (FlowMovie_GetSelfTimerID() != NULL_TIMER)
                {
                    FlowMovie_StopRecSelfTimer();
                    return NVTEVT_CONSUME;
                }
/*				
                if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
                {
                    g_uiRecordIngMotionDet = TRUE;
                } else {
                    g_uiRecordIngMotionDet = FALSE;
                }
*/
                // Isiah, implement YUV merge mode of recording func.
                if(FlowMovie_RecGetYUVMergeMode()) // Change IPL to movie record mode.
                {
                    IPL_SLEEP_INFO Info;


                    Movie_IPLChangeCB(MEDIAREC_IPLCHG_VIDEO, 0);
                    DBG_DUMP("Changed IPL to movie record mode\r\n");

                    Info.Id = 0;
                    IPL_SetCmd(IPL_SET_SLEEP, (void *)&Info);
                    IPL_WaitCmdFinish();
                }

                FlowMovie_StartRec();
                // start USB detect timer again
                if (g_ACPlug == TRUE)
                    SxTimer_SetFuncActive(SX_TIMER_DET_USB_ID, TRUE);
            }
            break;

        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM: // Isiah, implement YUV merge mode of recording func.
            if ((FlowMovie_GetRecCurrTime() >= 1) || FlowMovie_RecGetYUVMergeMode() ||
                (SysGetFlag(FL_MOVIE_TIMELAPSE_REC) != MOVIE_TIMELAPSEREC_OFF) 
                )//(uiState == UIFlowWndMovie_Restart_Rec))
            {
                FlowMovie_StopRec();
                // update ui window icon
		   UIFlowWndMovie_SetGsensorTrigFlag(FALSE);  
                FlowMovie_IconHideLockFile();
                FlowMovie_UpdateIcons(TRUE);
                //Ux_OpenWindow(&UIWndNotUseCtrl,0);
                //GxDisplay_Set(LAYER_OSD1, LAYER_STATE_ENABLE, 0); //turn off OSD1
                GxDisplay_Set(LAYER_OSD2, LAYER_STATE_ENABLE, 0); //turn off OSD2
                //GxDisplay_Set(LAYER_OSD1, LAYER_STATE_ENABLE, 1); //turn off OSD1
                GxDisplay_Set(LAYER_OSD2, LAYER_STATE_ENABLE, 1); //turn off OSD2
#if(_MODEL_DSC_ != _MODEL_PW8402_)					
                FlowMovie_UpdateIcons(TRUE);
#endif
                if (0)//(uiState==UIFlowWndMovie_Restart_Rec)
                {
#if (_MODEL_DSC_ == _MODEL_CARDV_)	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif                } else {
                /*
                    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
                    {
                        if (g_uiRecordIngMotionDet == TRUE)
                        {
                            g_uiRecordIngMotionDet = FALSE;
                        }
                    }
                    */
                }
            }
            break;
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_SHUTTER2,paramNum,paramArray);
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        if (0)//((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
        {
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            return NVTEVT_PASS;
        }
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            /* set Digital Zoom interface */
            UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

            gMovData.State |= MOV_ST_ZOOM;
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_IN, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

INT32 UIFlowWndMovie_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomOut][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
             /* set Digital Zoom interface */
             UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

             gMovData.State |= MOV_ST_ZOOM;
             Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_OUT, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

void UIFlowWndMovie_Initparam(void)
{
//#NT#2015/01/21#KS Hung -begin
//#NT#Fast boot recording.
#if ((USE_FILEDB) && (_FAST_BOOT_REC_FUNC_ == DISABLE))
//#NT#2015/01/21#KS Hung -end
    if (UI_GetData(FL_IsUseFileDB))
    {
       Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FILEID_RESET,0);
    }
#endif
    // The same effect as Photo mode
    //Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_WB,                  1,  SysGetFlag(FL_WB));

    // The other settings
//#NT#2015/01/21#KS Hung -begin
//#NT#Fast boot recording.
#if (_FAST_BOOT_REC_FUNC_)
    if (FlowMovie_GetFirstBootRecFlag() == FALSE)
    {
        Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,               1,  MOVIE_COLOR_NORMAL);
        Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
    }
#else
    //Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,               1,  MOVIE_COLOR_NORMAL);
    //Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
#endif
//#NT#2015/01/21#KS Hung -end

    /* Video resolution setting must be set after other IQ settings */
    {
        UINT32 uiSize;
        uiSize = SysGetFlag(FL_MOVIE_DUAL_REC) ? SysGetFlag(FL_MOVIE_SIZE_DUAL) : SysGetFlag(FL_MOVIE_SIZE);
        Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIESIZE,       1,  uiSize);
    }
    #if 1//(UVC_RECORD_FUNC == ENABLE)
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_IMAGE_RATIO,         1,  SysGetFlag(FL_MOVIE_SIZE));
    #endif

    /* Cyclic recording/record with mute or sound/DateImptint/Motion Detect */
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_CYCLIC_REC,          1,  SysGetFlag(FL_MOVIE_CYCLIC_REC));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOTION_DET,          1,  SysGetFlag(FL_MOVIE_MOTION_DET));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_DATE_IMPRINT,  1,  SysGetFlag(FL_MOVIE_DATEIMPRINT));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO,         1,  SysGetFlag(FL_MOVIE_AUDIO));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_EV,                  1,  SysGetFlag(FL_EV));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_GSENSOR,             1,  SysGetFlag(FL_MOVIE_GSENSOR));

    SysSetFlag(FL_MovieMCTFIndex, MOVIE_MCTF_ON); // forced enable MCTF
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_MCTF,          1,  SysGetFlag(FL_MovieMCTFIndex));
}

static CHAR  Speed_buf[64];
UINT32 uiSpeed = 0;
UINT32 uiSpeedKm = 0;

void FlowMovie_IconDrawSpeed(void)
{
   
    /*
        
        sprintf(Speed_buf,"%d ",uiSpeedKm);
        UxStatic_SetData(&UIFlowWndMovie_Txt_CurSpeedCtrl,STATIC_VALUE,Txt_Pointer(Speed_buf));
        UxCtrl_SetShow(&UIFlowWndMovie_Txt_CurSpeedCtrl,TRUE);
        */
}


void FlowMovie_IconHideSpeed(void)
{
/*
            sprintf(Speed_buf,"0 ");

	 UxStatic_SetData(&UIFlowWndMovie_Txt_CurSpeedCtrl,STATIC_VALUE,Txt_Pointer(Speed_buf));
        UxCtrl_SetShow(&UIFlowWndMovie_Txt_CurSpeedCtrl,TRUE);
        */
}

extern int SX_TIMER_DET_ReversingCAR_ID;

INT32 UIFlowWndMovie_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
   static BOOL firstpoweron=TRUE;
   UINT32 uiEdogWarningIndex=0;
    //#NT#2014/11/26#KS Hung -begin
    if(GSensor_open())
    {
    SxTimer_SetFuncActive(SX_TIMER_DET_GSENSOR_ID,TRUE);	
    }
    else
    {
    SxTimer_SetFuncActive(SX_TIMER_DET_GSENSOR_ID,FALSE);	
    }
    Movie_MenuSizeConfig();
    SxTimer_SetFuncActive(SX_TIMER_DET_ReversingCAR_ID, TRUE);
    //#NT#2014/11/26#KS Hung -end
    //GPIOMap_DVR_PowerOn();
    #if 0
	if(TouchPanel_IsInitOK()==TRUE){
	TouchPanel_SetInterupt(); 
	}
    #endif
//#NT#2015/01/21#KS Hung -begin
//#NT#Fast boot recording.
#if (_FAST_BOOT_REC_FUNC_)
    if (FlowMovie_GetFirstBootRecFlag() == TRUE)
    {
        FlowMovie_SetFirstBootRecFlag(FALSE);
        if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
        {
            gMovData.State= MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
            return NVTEVT_CONSUME;
        }
        else if (UI_GetData(FL_CardStatus) == CARD_LOCKED)
        {
            gMovData.State= MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED, FLOWWRNMSG_TIMER_KEEP);
            return NVTEVT_CONSUME;
        }


        
        // update g_uiRecordIngMotionDet flag
        if (gUIMotionDetTimerID==NULL_TIMER)
        {
            gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
        }

        if (g_uiDateTimerID == NULL_TIMER)
        {
            g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
        }

        if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
        {
            g_uiRecordIngMotionDet = TRUE;
        } else {
            g_uiRecordIngMotionDet = FALSE;
        }

        Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
        Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_GSENSOR,             1,  SysGetFlag(FL_MOVIE_GSENSOR));

        return NVTEVT_CONSUME;
    }
#endif
//#NT#2015/01/21#KS Hung -end

    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
    /* Init window key mask variables & set key and key released mask */
    g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
    g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyPress);

    UIFlowWndMovie_Initparam();
    FlowMovie_UpdateIcons(TRUE);
    if (UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE)
    {
       Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
    }

    // update g_uiRecordIngMotionDet flag
    if (gUIMotionDetTimerID==NULL_TIMER)
    {
        gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
    }

    if (g_uiDateTimerID == NULL_TIMER)
    {
        g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
    }

    // delete empty folder
    #if (USE_FILEDB==DISABLE)
    UIFlowWndMovie_DeleteEmptyFolder();
    #endif

    //#NT#2014/9/3#Philex Lin - begin
    // add time out mechanism to back to movei mode if nothing does in usb mode
    if (SysGetFlag(FL_MOVIE_USBRETURN))
    {
        // clear FL_MOVIE_USBRETURN flag
        SysSetFlag(FL_MOVIE_USBRETURN,FALSE);
        m_bACPlug = TRUE;
        //Ux_PostEvent(NVTEVT_AC_Plug, 0, 0);
    }
    //#NT#2014/9/3#Philex Lin - end
    
  
    
    FlowMovie_IconDrawSize();
    FlowMovie_IconDrawStorage();
    FlowMovie_IconDrawDateTime();
    UxCtrl_SetShow(&UIFlowWndMovie_RecPanelCtrl,FALSE);
    UxCtrl_SetShow(&UIFlowWndMovie_TXT_RECCtrl,FALSE);
       // UxCtrl_SetShow(&UIFlowWndMovie_Txt_DistanceCtrl,FALSE);
                
    FlowMovie_IconHideSpeed();
    GxUSB_UpdateConnectType();
    debug_msg("GxUSB_GetConnectType:%d..\r\n",GxUSB_GetConnectType());	
    if(GxUSB_GetConnectType()!= USB_CONNECT_PC)
    {
     		if(g_uiRecordIngMotionDet==FALSE)
     		{
	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
     		}
     }	
    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        if (FlowMovie_GetRecCurrTime() <= 1)
        {
            Delay_DelayMs(1000);
        }
        FlowMovie_StopRec();
        //Ux_SendEvent(&UIFlowWndMovieCtrl,NVTEVT_CB_MOVIE_FINISH,0); // useless
        // temporary solution: wait some time for IPL and display service ready to avoid video buffer corrupted (garbage screen)
        Delay_DelayMs(100);
        break;
    }

    g_bRedLEDOn = FALSE;
    //KeyScan_TurnOffLED(KEYSCAN_LED_RED);

    if (gUIMotionDetTimerID!=NULL_TIMER)
    {
        GxTimer_StopTimer(&gUIMotionDetTimerID);
    }

    if (g_uiDateTimerID != NULL_TIMER)
    {
        GxTimer_StopTimer(&g_uiDateTimerID);
    }
#if  (_SENSORLIB2_ != _SENSORLIB2_DUMMY_)
   PipView_SetStyle(PIP_STYLE_2T1B2S);
#endif
    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiSoundMask;
    UINT32 i;
    uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
        	switch(gMovData.State)
	        {
			case MOV_ST_VIEW:
			case MOV_ST_VIEW|MOV_ST_ZOOM:	  	
				// stope timer when entering menu
				/*
	            if (gUIMotionDetTimerID!=NULL_TIMER)
	            {
	                GxTimer_StopTimer(&gUIMotionDetTimerID);
	            }

	            if (g_uiDateTimerID != NULL_TIMER)
	            {
	                GxTimer_StopTimer(&g_uiDateTimerID);
	            }
	            // enable shutter2 sound (shutter2 as OK key in menu)
	            uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
	            uiSoundMask |= FLGKEY_SHUTTER2;
	            Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

	            Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
	            // Set Tab menu to Movie menu
	            TM_SetMenu(&gMovieMenu);
	            // Open common mix (Item + Option) menu
	            debug_msg("^G movie open menu\r\n");
	            Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
	            gMovData.State = MOV_ST_MENU;		
                */
	 		break;
        	}
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_MENU,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
//    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if(_MODEL_DSC_ == _MODEL_PW8402_)  
    UINT32  uiKeyAct;
    UINT32  uiEV;
	
    uiKeyAct = paramNum ? paramArray[0] : 0;
    switch (uiKeyAct) 
    {
    	case NVTEVT_KEY_PRESS:
#if 0			
		switch(SysGetFlag(FL_EDOGVOLUME))
		{
			case EDOG_VOLUME_1:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_4);
			break;
			case EDOG_VOLUME_2:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_1);
			break;
			case EDOG_VOLUME_3:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_2);
			break;
			case EDOG_VOLUME_4:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_3);
			break;			
			default:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_3);
			break;			
		}
    		UxState_SetData(&UIFlowWndMovie_Status_VolumeCtrl,STATE_CURITEM,SysGetFlag(FL_EDOGVOLUME));
   		EdgoRec_PutKeyCommand(MENU_VOLUME,SysGetFlag(FL_EDOGVOLUME));	
#else
		if(SysGetFlag(FL_EDOGMODE)==EDOG_ON)
		{
	   		if(gbQuickMute==FALSE)
	   		{
	   			gbQuickMute=TRUE;
	    			//UxState_SetData(&UIFlowWndMovie_Status_VolumeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Volume_ICON_VOL_OFF);
	   			EdgoRec_PutKeyCommand(MENU_QUICK_MUTE,0);	
	   		}
			else
	   		{
		   		gbQuickMute=FALSE;
	    			//UxState_SetData(&UIFlowWndMovie_Status_VolumeCtrl,STATE_CURITEM,SysGetFlag(FL_EDOGVOLUME)+1);
	   			EdgoRec_PutKeyCommand(MENU_QUICK_MUTE,0);	
	   		}			
		}
#endif
	break;
       case NVTEVT_KEY_CONTINUE:
   		  EdgoRec_PutKeyCommand(MENU_SET_XY,0);		   	
	break;
    }
    return NVTEVT_CONSUME;    
	
#else
    UINT32  uiKeyAct;
    UINT32  uiSelect;

    uiKeyAct = paramArray[0];
    uiSelect=  UI_GetData(FL_MOVIE_AUDIO);

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
      if(uiSelect == MOVIE_AUDIO_OFF)
      	{
#if (_MODEL_DSC_ == _MODEL_CARDV_)      	
    		GxLED_SetCtrl(KEYSCAN_LED_RED,TURNON_LED,TRUE);  
#endif
            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_ON);
      	}
	else
	{
#if (_MODEL_DSC_ == _MODEL_CARDV_)	
    		GxLED_SetCtrl(KEYSCAN_LED_RED,TURNON_LED,FALSE);
#endif
            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_AUDIO, 1, MOVIE_AUDIO_OFF);		
	}
	break;		
    }
   FlowMovie_IconDrawAudioOnOff();	
   return NVTEVT_CONSUME;
#endif
}
INT32 UIFlowWndMovie_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiEV;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_VIEW:
            case MOV_ST_VIEW|MOV_ST_ZOOM:
                uiEV = SysGetFlag(FL_EV);
                if (uiEV==EV_N20)
                {
                    SysSetFlag(FL_EV,EV_P20);
                } else {
                    SysSetFlag(FL_EV,++uiEV);
                }
                Ux_SendEvent(&CustomMovieObjCtrl,NVTEVT_EXE_MOVIE_EV,1, SysGetFlag(FL_EV));
                FlowMovie_IconDrawEV();
            break;
            case MOV_ST_REC:
                if(SysGetFlag(FL_MOVIE_CYCLIC_REC) != MOVIE_CYCLICREC_OFF && FlowMovie_GetRecCurrTime() >= 1)
                {
                    #if (0)//(PRJ == APC3)
                        g_bSpeLockFun = TRUE;
                        FlowMovie_StopRec();
                        Ux_SendEvent(pCtrl,NVTEVT_CB_MOVIE_FINISH,1,UIFlowWndMovie_Restart_Rec);
                    #endif
                }
            break;
         }
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_REC:
            case MOV_ST_REC|MOV_ST_ZOOM:
                if (FlowMovie_GetRecCurrTime() >= 1)
                {
                    UINT32  i, uiDAR[2], uiMovieSize;
                    USIZE   JpegSize[2];

                    FlowMovie_DrawPIM(TRUE);
                    if (UI_GetData(FL_MOVIE_DUAL_REC))
                    {
                        #if 0
                        // only support 1st sensor for raw encoding
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE_DUAL);
                        JpegSize[0].w = GetMovieSizeWidth_2p(0, uiMovieSize);
                        JpegSize[0].h = GetMovieSizeHeight_2p(0, uiMovieSize);
                        uiDAR[0] = GetMovieDispAspectRatio_2p(0, uiMovieSize);
                        if (uiDAR[0] == VIDENC_DAR_16_9)
                        {
                            JpegSize[0].w = (JpegSize[0].h * 16) / 9;
                        }
                        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 1, &JpegSize[0]);
                        #else
                        // support 1st & 2nd path image capture as dual recording
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE_DUAL);
                        for (i = 0; i < 2; i++) // max 2 paths
                        {
                            JpegSize[i].w = GetMovieSizeWidth_2p(i, uiMovieSize);
                            JpegSize[i].h = GetMovieSizeHeight_2p(i, uiMovieSize);
                            uiDAR[i] = GetMovieDispAspectRatio_2p(i, uiMovieSize);
                            if (uiDAR[i] == VIDENC_DAR_16_9)
                            {
                                JpegSize[i].w = (JpegSize[i].h * 16) / 9;
                            }
                        }
                        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, &JpegSize[0], &JpegSize[1]);
                        #endif
                    }
                    else
                    {
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
                        JpegSize[0].w = GetMovieSizeWidth(uiMovieSize);
                        JpegSize[0].h = GetMovieSizeHeight(uiMovieSize);
                        uiDAR[0] = GetMovieDispAspectRatio(uiMovieSize);
                        if (uiDAR[0] == VIDENC_DAR_16_9)
                        {
                            JpegSize[0].w = (JpegSize[0].h * 16) / 9;
                        }
                        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 1, &JpegSize[0]);
                    }
                }
                break;
         }
         break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiSoundMask;

    switch (gMovData.State)
    {
    case MOV_ST_WARNING_MENU:
         //#NT#2015/01/21#KS Hung -begin
         #if (_FAST_BOOT_REC_FUNC_)
         if ((UI_GetData(FL_CardStatus) == CARD_REMOVED) || (UI_GetData(FL_CardStatus) == CARD_LOCKED))
         {
             FlowMovie_UpdateIcons(TRUE);
             gMovData.State = MOV_ST_VIEW;
             break;
         }
         #endif
         //#NT#2015/01/21#KS Hung -end
         if(paramNum > 0)
           {
                if(paramArray[0] == NVTRET_ENTER_MENU)
                {
                    /* Create Menu window */
                    gMovData.State = MOV_ST_MENU;

                    return NVTEVT_CONSUME;
                }
            }
            gMovData.State = MOV_ST_VIEW;
        break;

    case MOV_ST_MENU:
        // disable shutter2 sound
        uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
        uiSoundMask &= ~FLGKEY_SHUTTER2;
        Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);
		
        if(SysGetFlag(FL_EDOGMODE)==EDOG_ON)
		gbEdogPhaseMessageEn=TRUE;
		
         g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
         g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
         Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
         Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
         FlowMovie_UpdateIcons(TRUE);
       
         // start timer again when exiting menu
         if (gUIMotionDetTimerID==NULL_TIMER)
         {
           gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
         }

         if (g_uiDateTimerID == NULL_TIMER)
         {
           g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
         }

         gMovData.State = MOV_ST_VIEW;
        break;
    }

    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
    {
        g_uiRecordIngMotionDet = TRUE;
    } else {
        g_uiRecordIngMotionDet = FALSE;
    }
     if(paramNum > 0)
       {
            if(paramArray[0] == START_MOVIE_RECORD)
            {	
     		if(g_uiRecordIngMotionDet==FALSE)
     		{
	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
     		}            
            }
     	}
   //Ux_RedrawAllWind();
    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_MODEL_DSC_ == _MODEL_CARDV_)
    UINT32  uiKeyAct;
    uiKeyAct = paramArray[0];
    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
	      if((KeyScan_GetPlugDev() != 1)&&(KeyScan_GetPlugDev() != 2))
	     	{
	     		if(GPIOMap_IsLCDBacklightOn()==TRUE)
			GPIOMap_TurnOffLCDBacklight();
			else
			GPIOMap_TurnOnLCDBacklight();				
	     	}	  	
	  break;
    }
    return NVTEVT_CONSUME;
	
#else
    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
#endif
}
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomIn(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomOut(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_MODEL_DSC_ == _MODEL_CARDV_)
    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
    //return UIFlowWndMovie_OnExeZoomIn(pCtrl, paramNum, paramArray);
#elif(_MODEL_DSC_ == _MODEL_PW8402_)  
    UINT32  uiKeyAct;
    UINT32  uiEV;
	
    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct) 
    {
    	case NVTEVT_KEY_PRESS:
#if 0			
		switch(SysGetFlag(FL_EDOGVOLUME))
		{
			case EDOG_VOLUME_1:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_2);
			break;
			case EDOG_VOLUME_2:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_3);
			break;
			case EDOG_VOLUME_3:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_4);
			break;
			case EDOG_VOLUME_4:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_1);
			break;			
			default:
				SysSetFlag(FL_EDOGVOLUME,EDOG_VOLUME_3);
			break;			
		}
    		UxState_SetData(&UIFlowWndMovie_Status_VolumeCtrl,STATE_CURITEM,SysGetFlag(FL_EDOGVOLUME));
   		EdgoRec_PutKeyCommand(MENU_VOLUME,SysGetFlag(FL_EDOGVOLUME));	
#else
           if(SysGetFlag(FL_EDOGMODE)==EDOG_ON)
           {
                     SysSetFlag(FL_EDOGMODE,EDOG_OFF);
   	     		EdgoRec_PutKeyCommand(MENU_QUICK_MUTE,0X02);	
         	       FlowMovie_UpdateIcons(TRUE);				
           }
           else
           {
                     SysSetFlag(FL_EDOGMODE,EDOG_ON);
   	     		EdgoRec_PutKeyCommand(MENU_QUICK_MUTE,0X03);	
         		FlowMovie_UpdateIcons(TRUE);				
           }		   	
#endif
	break;
       case NVTEVT_KEY_CONTINUE:
   		EdgoRec_PutKeyCommand(MENU_GET_IMEI_INFO,0);	
	 break;
    }
#else    
    UINT32  uiKeyAct;
    UINT32  uiEV;
	
    uiKeyAct = paramNum ? paramArray[0] : 0;
   debug_msg("System_OnPipSetting : %d..\r\n",PipView_GetStyle());

    switch (uiKeyAct) 
    {
    case NVTEVT_KEY_PRESS:	
	    switch(PipView_GetStyle())
	    {
		    //case PIP_STYLE_1T1F:
			//PipView_SetStyle(PIP_STYLE_1T1B2S);
			//break;
		    case PIP_STYLE_1T1F://PIP_STYLE_1T1B2S:
			PipView_SetStyle(PIP_STYLE_1T1S2B);
			break;
		    case PIP_STYLE_1T1S2B:
			PipView_SetStyle(PIP_STYLE_2T2F);
			break;
		    case PIP_STYLE_2T2F:
			PipView_SetStyle(PIP_STYLE_2T1B2S);
			break;
		    case PIP_STYLE_2T1B2S:
			PipView_SetStyle(PIP_STYLE_2T1S2B);
			break;
		    case PIP_STYLE_2T1S2B:
			PipView_SetStyle(PIP_STYLE_1T1F);
			break;		
	    }    
	break;
    	}
#endif	
    return NVTEVT_CONSUME;    
}
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FORCETO_PLAYBACK_MODE,0);
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 static volatile BOOL bBatteryOn = FALSE;

    UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl,STATE_CURITEM,GetBatteryLevel());
    if (KeyScan_IsACIn())
    {
        bBatteryOn = !bBatteryOn;
        if (bBatteryOn==FALSE)
            UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl,STATE_CURITEM,UIFlowWndMovie_Status_battery_ICON_BATTERY_CHARGE);
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,TRUE);
    } else {
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,TRUE);
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_EXE_CHANGEDSCMODE,1,DSCMODE_CHGTO_NEXT);
        break;
	 case MOV_ST_REC:
       case MOV_ST_REC|MOV_ST_ZOOM:
	     if(g_bgsensor==FALSE)
	     {
		g_bgsensor = TRUE;     
	       MediaRec_SetCrash();	
		FlowMovie_IconDrawLockFile();
	     }		
	break;
    }
    return NVTEVT_CONSUME;
}
//#NT#2014/06/30#Hideo Lin -begin
//#NT#Don't need to handle this event; this event will be issued after recording stop,
//#NT#and cause handling previous one if shutter key was pressed frequently.
//#NT#In fact, the handling codes here are almost duplicated with other events...
#if 0
INT32 UIFlowWndMovie_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiFolderId, uiFileId;
    BOOL    CheckStorageErr;
    //UINT32  gUIAviRecMaxTime;

    switch (gMovData.State)
    {
      case MOV_ST_REC:
      case MOV_ST_REC|MOV_ST_ZOOM:
            #if 0
            if(UIStorageCheck(STORAGE_CHECK_FULL, &(gUIAviRecMaxTime)) != TRUE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);
            }
            #endif
            //gMovData.State = MOV_ST_VIEW;
            g_uiRecordIngMotionDet = FALSE;
            //#NT#2012/10/23#Philex Lin - begin
            // enable auto power off/USB detect timer
            KeyScan_EnableMisc(TRUE);
            //#NT#2012/10/23#Philex Lin - end
            FlowMovie_IconDrawMaxRecTime();
            UxState_SetData(&UIFlowWndMovie_Status_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_REC_ICON_TRANSPAENT);

            //if (FlowMovie_ChkDrawStoreFullFolderFull() == FALSE)
            if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
            {
                CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
            } else {
                CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
            }
            if (CheckStorageErr == FALSE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);

                FlowMovie_UpdateIcons(TRUE);
                Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
            }
            break;

        //The flow here may be only for APC3 stop record than lock file function.
        //To be careful that gMovData have changed in UIFlowMovie_Stop.
        case MOV_ST_VIEW:
            #if (0)//(PRJ == APC3)
            if (paramNum)
            {
                if (paramArray[0]==UIFlowWndMovie_Restart_Rec)
                {
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                }
            }
            #endif
            break;
    }

    return NVTEVT_CONSUME;
}
#endif
//#NT#2014/06/30#Hideo Lin -end
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  static volatile BOOL bRecordShow = FALSE;
  UINT32 uiRecSecond, uiCyclicRecTime;

    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        bRecordShow = !bRecordShow;
       
            


        if (paramNum)
        {
            //UINT32 uiRecSecond, uiCyclicRecTime;

            uiRecSecond = paramArray[0];
            uiCyclicRecTime = Movie_GetCyclicRecTime();
            UxCtrl_SetShow(&UIFlowWndMovie_RecPanelCtrl,uiCyclicRecTime%2);
            if (uiRecSecond > uiCyclicRecTime)
            {
                uiRecSecond -= uiCyclicRecTime;
            }
            FlowMovie_SetRecCurrTime(uiRecSecond);

            //#NT#2014/4/14#Philex Lin - begin
            // add cyclic recording with time lapse function
            #if USE_FILEDB
            if (SysGetFlag(FL_MOVIE_TIMELAPSE_REC)!=MOVIE_TIMELAPSEREC_OFF)
            {
                if (SysGetFlag(FL_MOVIE_CYCLIC_REC)!=MOVIE_CYCLICREC_OFF)
                {
                    if (paramArray[0]==uiCyclicRecTime)
                    {
                        //if (FlowMovie_GetRecCurrTime() >= 1 || FlowMovie_RecGetYUVMergeMode())
                        {
                            // stop recording
                            FlowMovie_StopRec();

                            // delete old files if disk is almost full
                            UIFlowWndMovie_OnDeleteOld();

                            // start recording again
#if (_MODEL_DSC_ == _MODEL_CARDV_)	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif
                        }
                    }
                }
            }
            #endif
            //#NT#2014/4/14#Philex Lin - end
        }
        FlowMovie_IconDrawRecTime();
	  if(GSensor_GMA301_CrashMode()==TRUE)
	  {
		if((UIFlowWndMovie_IsGsensorTrig()==FALSE)&&(uiRecSecond>1))	
		{
			g_bgsensor = TRUE;     
		      MediaRec_SetCrash();	
			FlowMovie_IconDrawLockFile();
		}
	      if(uiRecSecond==30)//30 sensonds
	      	{
			 GSensor_GMA301_ClearCrashMode();	     
			 UIFlowWndMovie_SetGsensorTrigFlag(FALSE);    
	  		 FlowMovie_IconHideLockFile();			 
                    FlowMovie_StopRec();
                    if ( FALSE == AE_Wait_Stable(3, 60) )
                        DBG_ERR("Movie one seocond EVENT: AE do not stable\r\n");
		}		
	  }
       
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnLoopRecFull(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnOverTime(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  BOOL    isNeedRecordAgain=FALSE;

    if (gMovData.State&MOV_ST_REC)
    {
        isNeedRecordAgain = TRUE;
    } else {
        isNeedRecordAgain = FALSE;
    }
    FlowMovie_StopRec();
    //#NT#2012/10/23#Philex Lin - begin
    //enable auto power off/USB detect timer
    KeyScan_EnableMisc(TRUE);
    //#NT#2012/10/23#Philex Lin - end

        if (TRUE==isNeedRecordAgain)
        {
#if (_MODEL_DSC_ == _MODEL_CARDV_)	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif
        }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieWrError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    if ((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM)))
    {
        FlowMovie_StopRec();
        #if (_DUAL_CARD_FUNC_ == ENABLE)
        if ((UI_GetData(FL_CardStatus) == CARD_LOCKED) || (UI_GetData(FL_Card2Status) == CARD_LOCKED))
        #else
        if (UI_GetData(FL_CardStatus) == CARD_LOCKED)
        #endif
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_3SEC);
            return NVTEVT_CONSUME;
        }
        else
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR,FLOWWRNMSG_TIMER_3SEC);
            return NVTEVT_CONSUME;
        }
    }
    else
    {
        Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // trigger re-start encoding
    #if 0
    return UIFlowWndMovie_OnExeRecord(pCtrl, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
    #else
    Movie_SetSDSlow(TRUE);
#if (_MODEL_DSC_ == _MODEL_CARDV_)	     
  //  Ux_PostEvent(NVTEVT_KEY_UP, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
  //  Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#endif	

    return NVTEVT_CONSUME;
    #endif
}
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_StopRec();
    KeyScan_EnableMisc(TRUE);
    //gMovData.State = MOV_ST_VIEW;
    gMovData.State= MOV_ST_WARNING_MENU;
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL,FLOWWRNMSG_TIMER_2SEC);
    FlowMovie_IconDrawMaxRecTime();
    return NVTEVT_CONSUME;
}
#if 0
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    ide_enable_video(IDE_VIDEOID_1);
    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnRAWEncOK(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  CHAR Path[60];

    RawEnc_GetPath(&Path[0]);
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_IconDrawDZoom();
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if (_DUAL_CARD_FUNC_)
    if (SysGetFlag(FL_CardChange) == CARD_CHANGE_YES)
    {
        SysSetFlag(FL_CardChange, CARD_CHANGE_NO);
        SysSetFlag(FL_MOVIE_CYCLIC_REC,             MOVIE_CYCLICREC_3MIN);
        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_CYCLIC_REC, 1, SysGetFlag(FL_MOVIE_CYCLIC_REC));
        FlowMovie_IconDrawMaxRecTime();
        FlowMovie_IconDrawCyclicRec();

        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
    }
    #endif

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiEvent;

    if (paramNum>0)
    {
        uiEvent = paramArray[0];
        if (uiEvent != NVTEVT_ALGMSG_PREVIEW_STABLE)
            return NVTEVT_CONSUME;
    } else {
        return NVTEVT_CONSUME;
    }

    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    g_PreviewStable = TRUE;
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_UpdateIcons(TRUE);

    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyRelease);
    return NVTEVT_CONSUME;
}
#if (GPS_FUNCTION == ENABLE)
static BOOL  UIFlowWndMovie_UpdateSpeedData(void)
{
    RMCINFO RMCInfo;
    UINT32 day = 0, month = 0, year = 0, hour = 0, min = 0, sec = 0;
    UINT8	uiTimeZone = 0;
    UINT32 Days;
    UINT32 lastSec = 0;;
    RTC_DATE rtcDate;
    static UINT32 uiGPSCounter = 0;
    static UINT32 uiGPSCounter2 = 0;
    
      GPSRec_GetRMCDate(&RMCInfo);
            
      if(GPSRec_CheckData() == TRUE)
      {
            // memcpy(&(gpsdata.rmcinfo),&RMCInfo,sizeof(RMCINFO));
     
             //UxState_SetData(&UIFlowWndMovie_Icon_GPSCtrl,STATE_CURITEM,TRUE);
          // debug_msg("RD_IS_Connect3 = %d\r\n",RDInfo.RD_IS_Connect);
          if(RDInfo.RD_IS_Connect)
          {
	      	UxState_SetData(&UIFlowWndMovie_Icon_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_GPS_ICON_GPS_ON_RD_EN);	
          }
		  else
		  {
		  	UxState_SetData(&UIFlowWndMovie_Icon_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_GPS_ICON_GPS_ON_RD_DIS);
		  }
          UxCtrl_SetShow(&UIFlowWndMovie_Icon_GPSCtrl, TRUE);          
             
             if(gbUpdteGPSTime==FALSE)
             {
                 if(uiGPSCounter>5)
                 {
                     gbUpdteGPSTime=TRUE;
                     UIFlowwndMovieUpdateGPSTime();
                 }
                 else
                 {
                        uiGPSCounter++;
                 }
             }
     
             //lastSec = RMCInfo.Second;
             //Show_RD_Speed((int)RMCInfo.Speed/1);
             //UIFlowwndMovieUpdateGPSTime();      
             memcpy(&(gpsdata.rmcinfo),&RMCInfo,sizeof(RMCINFO));      
        
       	if (lastSec != RMCInfo.Second)
       	{
       		//debug_err(("UIFlowWndMovie_Update_Speed... GPS_Second_Pre != RMCInfo.Second\r\n"));
       		lastSec = RMCInfo.Second;	
       		uiGPSCounter2=0;
       	}
       	else
       	{
        		uiGPSCounter2++;
        		if(uiGPSCounter2>5)
        		{
        			//debug_err(("UIFlowWndMovie_Update_Speed... GPS_Second_Pre == RMCInfo.Second==========\r\n"));
        		    gbUpdteGPSTime=FALSE;
                    GPSRec_Reset();
					//debug_msg("RD_IS_Connect1 = %d\r\n",RDInfo.RD_IS_Connect);
            		if(RDInfo.RD_IS_Connect)
      				{
        				UxState_SetData(&UIFlowWndMovie_Icon_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_GPS_ICON_GPS_OFF_RD_EN);
      				}
					else
					{
						UxState_SetData(&UIFlowWndMovie_Icon_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_GPS_ICON_GPS_OFF_RD_DIS);
					}
                    UxCtrl_SetShow(&UIFlowWndMovie_Icon_GPSCtrl, TRUE);                        
        		}
    	  }        			
      }
      else
      {
      	//debug_msg("RD_IS_Connect2 = %d\r\n",RDInfo.RD_IS_Connect);
      	if(RDInfo.RD_IS_Connect)
      	{
        	UxState_SetData(&UIFlowWndMovie_Icon_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_GPS_ICON_GPS_OFF_RD_EN);
      	}
		else
		{
			UxState_SetData(&UIFlowWndMovie_Icon_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_GPS_ICON_GPS_OFF_RD_DIS);
		}
        UxCtrl_SetShow(&UIFlowWndMovie_Icon_GPSCtrl, TRUE);
      }
   return TRUE;     
      #if 0
      debug_msg("lati:%1f, NS:%c, longi:%1f,EW:%c\r\n",gpsdata.rmcinfo.Latitude,gpsdata.rmcinfo.NSInd,gpsdata.rmcinfo.Longitude,gpsdata.rmcinfo.EWInd);
      #endif
}
#endif
CHAR    RD_str[20] = {0};
void Show_RD_VolLvl(UINT32 lvl)
{
    UxCtrl_SetShow(&UIFlowWndMovie_Radar_Vol_LvlCtrl,FALSE);
    sprintf(RD_str,"%d",lvl);  
    if(lvl>0)
        lvl -=1;

    if(lvl < 9)
    UxState_SetData(&UIFlowWndMovie_Radar_Vol_LvlCtrl,STATE_CURITEM,lvl);
    
    UxCtrl_SetShow(&UIFlowWndMovie_Radar_Vol_LvlCtrl,TRUE);
}
void Show_RD_Mode(UINT32 mode)
{
    if(mode == 0 ||mode == 1)
    UxState_SetData(&UIFlowWndMovie_Radar_ModeCtrl,STATE_CURITEM,mode);
    UxCtrl_SetShow(&UIFlowWndMovie_Radar_ModeCtrl,TRUE);
}

void Show_RD_Speed(UINT32 speed,BOOL Enb)
{
    UINT32 SpeedTotal;
    UINT32 SpeedTotal1,SpeedTotal2,SpeedTotal3;
	static UINT8 flag = 0;
       SpeedTotal=speed; 
       
	SpeedTotal1=SpeedTotal/100;
	if((SpeedTotal1<0)||(SpeedTotal1>9))
	  SpeedTotal1=0;
    
	SpeedTotal2=(SpeedTotal%100)/10;	
	if((SpeedTotal2<0)||(SpeedTotal2>9))
	  SpeedTotal2=0;	
    
	SpeedTotal3=(SpeedTotal%100)%10;	
	if((SpeedTotal3<0)||(SpeedTotal3>9))
	  SpeedTotal3=0;	

         UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_LCtrl,FALSE);
         UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_MCtrl,FALSE);
         UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_HCtrl,FALSE);
         UxCtrl_SetShow(&UIFlowWndMovie_CurSpeedCtrl,FALSE);
             
        if(Enb)
        {   
            UxState_SetData(&UIFlowWndMovie_CurSpeed_HCtrl,STATE_CURITEM,SpeedTotal1);
            UxState_SetData(&UIFlowWndMovie_CurSpeed_MCtrl,STATE_CURITEM,SpeedTotal2);
            UxState_SetData(&UIFlowWndMovie_CurSpeed_LCtrl,STATE_CURITEM,SpeedTotal3);
            
            if((SpeedTotal1==0)&&(SpeedTotal2==0))
            {
                UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_HCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_MCtrl,FALSE);            
                UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_LCtrl,TRUE);                            
            }         
            else if((SpeedTotal1==0)&&(SpeedTotal2!=0))
            {
                UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_HCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_MCtrl,TRUE);            
                UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_LCtrl,TRUE);                            
            }   
            else if(SpeedTotal1!=0)
            {
                UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_HCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_MCtrl,TRUE);            
                UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_LCtrl,TRUE);                                            
            }  
			
			UxCtrl_SetShow(&UIFlowWndMovie_CurSpeedCtrl,TRUE);
               
        }
        else
        {
             UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_LCtrl,TRUE);
             UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_MCtrl,FALSE);
             UxCtrl_SetShow(&UIFlowWndMovie_CurSpeed_HCtrl,FALSE);
             UxCtrl_SetShow(&UIFlowWndMovie_CurSpeedCtrl,TRUE);
        }        
}
void Show_RD_Distance(UINT32 distance)
{
    /*
    sprintf(RD_str,"%d",distance);  
    UxStatic_SetData(&UIFlowWndMovie_Txt_DistanceCtrl,STATIC_VALUE,Txt_Pointer(RD_str));
    if(distance == 0)
        UxCtrl_SetShow(&UIFlowWndMovie_Txt_DistanceCtrl,FALSE);
    else
    UxCtrl_SetShow(&UIFlowWndMovie_Txt_DistanceCtrl,TRUE);
    */
}

enum{
ANGLE_EAST,
ANGLE_SOUTHEAST,
ANGLE_SOUTH,
ANGLE_SOUTHWEST,
ANGLE_WEST,
ANGLE_NORTHWEST,
ANGLE_NORTH,
ANGLE_NORTHEAST
};

enum{
RD_WAR_NONE,
RD_WAR_WAR_TYPE,
RD_WAR_SPEED_LIMIT,
RD_WAR_DISTANCE_1,
RD_WAR_SPEEDLIMIT_AND_DISTANCE,
RD_WAR_DISTANCE_2
};

enum{
RD_band_NONE,
RD_band_KU,
RD_band_LASER,
RD_band_Strelka,
RD_band_X,
RD_band_KA,
RD_band_K
};


static UINT32 AngleIndex;
static UINT32 lastAngleIndex;
void Show_RD_Angle(UINT32 uiAngel)
{
#if 0
    double ret;
    debug_msg("^G uiAngel  %f\r\n",uiAngel);
    ret =  fmod((uiAngel+ 22.5),360);
    debug_msg("^G change  %lf\r\n",ret);
    AngleIndex =  (ret/45);
    debug_msg("^G change to angle  %d\r\n",AngleIndex);
    switch(AngleIndex)
    {
        case 0:
            AngleIndex = ANGLE_NORTH ;   
            break;
        case 1:
            AngleIndex = ANGLE_NORTHEAST ;   
            break;
        case 2:
            AngleIndex = ANGLE_EAST ;   
            break;
        case 3:
            AngleIndex = ANGLE_SOUTHEAST ;   
            break;
        case 4:
            AngleIndex = ANGLE_SOUTH ;   
            break;
        case 5:
            AngleIndex = ANGLE_SOUTHWEST ;   
            break;
        case 6:
            AngleIndex = ANGLE_WEST ;   
            break;
        case 7:
            AngleIndex = ANGLE_NORTHWEST ;   
            break;
           default :
            AngleIndex = ANGLE_NORTH ;  
            break;
    }
    
    UxState_SetData(&UIFlowWndMovie_AngleCtrl,STATE_CURITEM,AngleIndex);
    UxCtrl_SetShow(&UIFlowWndMovie_AngleCtrl,TRUE);
    if(AngleIndex  != lastAngleIndex)
        {
        Refresh_Screen_Display();
        }
        //Ux_OpenWindow(&UIWndNotUseCtrl,0);
    lastAngleIndex = AngleIndex;
#else
   // uiAngel=(uiAngel*2%360);
    uiAngel=(UINT32)((uiAngel/1)%360);
    //debug_msg("^G  uiAngel: %d\r\n",uiAngel);
	if(((uiAngel>=0)&&(uiAngel<23))&&((uiAngel>338)&&(uiAngel<=360)))
	{	
		AngleIndex=ANGLE_NORTH;//ANGLE_EAST;
	}
	else if((uiAngel>=23)&&(uiAngel<68))
	{
		AngleIndex=ANGLE_NORTHEAST;//ANGLE_SOUTHEAST;
	}
	else if((uiAngel>=68)&&(uiAngel<113))
	{
		AngleIndex=ANGLE_EAST;//ANGLE_SOUTH;
	}	
	else if((uiAngel>=113)&&(uiAngel<158))
	{
		AngleIndex=ANGLE_SOUTHEAST;//ANGLE_SOUTHWEST;
	}
	else if((uiAngel>=158)&&(uiAngel<203))
	{
		AngleIndex=ANGLE_SOUTH;//ANGLE_WEST;
	}	
	else if((uiAngel>=203)&&(uiAngel<248))
	{
		AngleIndex=ANGLE_SOUTHWEST;//ANGLE_NORTHWEST;
	}	
	else if((uiAngel>=248)&&(uiAngel<293))
	{
		AngleIndex=ANGLE_WEST;//ANGLE_NORTH;
	}
	else if((uiAngel>=293)&&(uiAngel<=338))
	{
		AngleIndex=ANGLE_NORTHWEST;//ANGLE_NORTHEAST;
	}
       else
       {
              AngleIndex=ANGLE_NORTHWEST;
       }
    
    if(AngleIndex  != lastAngleIndex)
    {
        //Refresh_Screen_Display();
        UxCtrl_SetShow(&UIFlowWndMovie_AngleCtrl,FALSE);                
        UxState_SetData(&UIFlowWndMovie_AngleCtrl,STATE_CURITEM,AngleIndex);
        UxCtrl_SetShow(&UIFlowWndMovie_AngleCtrl,TRUE);        
    }
    lastAngleIndex = AngleIndex;
   #endif
}


void ShowRDSingalLvl(UINT32 lvl)
{
    if((lvl<0)||(lvl>9))
    {
           return;
    }
    
    UxCtrl_SetShow(&Static93Ctrl,FALSE);
    UxCtrl_SetShow(&Static94Ctrl,FALSE);
    UxCtrl_SetShow(&Static95Ctrl,FALSE);
    UxCtrl_SetShow(&Static95CCtrl,FALSE);

    UxStatic_SetData(&Static93Ctrl,STATIC_VALUE,ICON_RADAR_FAIL);
    UxStatic_SetData(&Static94Ctrl,STATIC_VALUE,ICON_RADAR_FAIL);
    UxStatic_SetData(&Static95Ctrl,STATIC_VALUE,ICON_RADAR_FAIL);
    UxStatic_SetData(&Static95CCtrl,STATIC_VALUE,ICON_RADAR_FAIL);

    switch(lvl)
        {
        case 1:
        case 2:
            UxStatic_SetData(&Static93Ctrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);
            break;
        case 3:
        case 4:
            UxStatic_SetData(&Static93Ctrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);
            UxStatic_SetData(&Static94Ctrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);
            break;
        case 5:
        case 6:
            UxStatic_SetData(&Static93Ctrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);
            UxStatic_SetData(&Static94Ctrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);
            UxStatic_SetData(&Static95Ctrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);

            break;
        case 7:
        case 8:
        case 9:
            UxStatic_SetData(&Static93Ctrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);
            UxStatic_SetData(&Static94Ctrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);
            UxStatic_SetData(&Static95Ctrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);
            UxStatic_SetData(&Static95CCtrl,STATIC_VALUE,ICON_RADAR_SINGAL_OK);
            break;
        }
    UxCtrl_SetShow(&Static93Ctrl,TRUE);
    UxCtrl_SetShow(&Static94Ctrl,TRUE);
    UxCtrl_SetShow(&Static95Ctrl,TRUE);
    UxCtrl_SetShow(&Static95CCtrl,TRUE);
    
}

static CHAR    GPSDB_str[128] = "no  signal....";
#define SHOW_SAT_NUM  0
#define SHOW_SAT_DATALEN  4
#if SHOW_SAT_NUM
#else
void ChangeSequence(UINT32 Data[] ,UINT32 DataLen)
{
    UINT32 i, j, temp; 
   
    for (i = 0; i <= DataLen - 1; i++)
    {
        for ( j = DataLen - 1; j > i; j--)
        {
            if (Data[j] > Data[j - 1])
            {
                temp = Data[j];
                Data[j] = Data[j - 1];
                Data[j - 1] = temp;
            }
        }
    }
   
    

}  
#endif


void UIFlowWndMovie_EdogInfo(void)
{
    RDINFO RDInfo;
    GSVINFO RD_GSV;
    RMCINFO RMCInfo;
    static BOOL FirstEdog = TRUE;
    static BOOL NeedRedorwWindow = FALSE;
    static BOOL RDNeedRedorwWindow = FALSE;
    #if SHOW_SAT_NUM
    #else
    UINT32 SAT_SIGNAL[4];
    #endif
    UINT32 uiCurrentSpeed=0;
    static BOOL flag = 0;
    
    GPSRec_GetRMCDate(&RMCInfo);
    GetRDInfo(&RDInfo);
    GetGPSSingalLvl(&RD_GSV);

#if 0
    //if(RMCInfo.Status == 'A')
        {
        debug_msg("^G  NumOfSen:%d  ",RD_GSV.NumOfSen);
    switch(RD_GSV.NumOfSen)
        {
        case 1:
            debug_msg("^G  SAT01:%d  dB;SAT02:%d  dB;SAT03:%d  dB;SAT04:%d  dB\r\n",
                RD_GSV.SAT01.SNR ,RD_GSV.SAT02.SNR ,RD_GSV.SAT03.SNR ,RD_GSV.SAT04.SNR);
            #if SHOW_SAT_NUM
            sprintf(GPSDB_str,"SAT01:%d  dB;SAT02:%d  dB;SAT03:%d  dB;SAT04:%d  dB",
            RD_GSV.SAT01.SNR ,RD_GSV.SAT02.SNR ,RD_GSV.SAT03.SNR ,RD_GSV.SAT04.SNR );
            #else
            SAT_SIGNAL[0] = RD_GSV.SAT01.SNR;
            SAT_SIGNAL[1] = RD_GSV.SAT02.SNR;
            SAT_SIGNAL[2] = RD_GSV.SAT03.SNR;
            SAT_SIGNAL[3] = RD_GSV.SAT04.SNR;
            ChangeSequence(SAT_SIGNAL,SHOW_SAT_DATALEN);
                debug_msg("^Y   %d  %d  %d  %d\r\n",SAT_SIGNAL[0],SAT_SIGNAL[1],SAT_SIGNAL[2],SAT_SIGNAL[3]);
            #endif
            break;
            case 2:
                debug_msg("^G SAT05:%d  dB;SAT06:%d  dB;SAT07:%d  dB;SAT08:%d  dB\r\n",
                RD_GSV.SAT05.SNR ,RD_GSV.SAT06.SNR ,RD_GSV.SAT07.SNR ,RD_GSV.SAT08.SNR);
                #if SHOW_SAT_NUM
                sprintf(GPSDB_str,"SAT05:%d  dB;SAT06:%d  dB;SAT07:%d  dB;SAT08:%d  dB",
            RD_GSV.SAT05.SNR ,RD_GSV.SAT06.SNR ,RD_GSV.SAT07.SNR ,RD_GSV.SAT08.SNR );
                #else
            SAT_SIGNAL[0] = RD_GSV.SAT05.SNR;
            SAT_SIGNAL[1] = RD_GSV.SAT06.SNR;
            SAT_SIGNAL[2] = RD_GSV.SAT07.SNR;
            SAT_SIGNAL[3] = RD_GSV.SAT08.SNR;
            ChangeSequence(SAT_SIGNAL,SHOW_SAT_DATALEN);
                debug_msg("^Y   %d  %d  %d  %d\r\n",SAT_SIGNAL[0],SAT_SIGNAL[1],SAT_SIGNAL[2],SAT_SIGNAL[3]);
            #endif
            break;
            case 3:
                debug_msg("^G SAT09:%d  dB;SAT10:%d  dB;SAT11:%d  dB;SAT12:%d  dB\r\n",
                RD_GSV.SAT09.SNR ,RD_GSV.SAT10.SNR ,RD_GSV.SAT11.SNR ,RD_GSV.SAT12.SNR);
                #if SHOW_SAT_NUM
                sprintf(GPSDB_str,"SAT09:%d  dB;SAT10:%d  dB;SAT11:%d  dB;SAT12:%d  dB",
            RD_GSV.SAT09.SNR ,RD_GSV.SAT10.SNR ,RD_GSV.SAT11.SNR ,RD_GSV.SAT12.SNR );
                #else
            SAT_SIGNAL[0] = RD_GSV.SAT09.SNR;
            SAT_SIGNAL[1] = RD_GSV.SAT10.SNR;
            SAT_SIGNAL[2] = RD_GSV.SAT11.SNR;
            SAT_SIGNAL[3] = RD_GSV.SAT12.SNR;
            ChangeSequence(SAT_SIGNAL,SHOW_SAT_DATALEN);
                debug_msg("^Y   %d  %d  %d  %d\r\n",SAT_SIGNAL[0],SAT_SIGNAL[1],SAT_SIGNAL[2],SAT_SIGNAL[3]);
            #endif
            break;
        }
        }
#else
        SAT_SIGNAL[0] = RDInfo.GPS_SNR1;
        SAT_SIGNAL[1] = RDInfo.GPS_SNR2;
        SAT_SIGNAL[2] = RDInfo.GPS_SNR3;
        SAT_SIGNAL[3] = RDInfo.GPS_SNR4;
        
#endif
#if SHOW_SAT_NUM

#else
     sprintf(GPSDB_str,"%d      %d      %d       %d ",
     SAT_SIGNAL[0] ,SAT_SIGNAL[1] ,SAT_SIGNAL[2] ,SAT_SIGNAL[3] );
#endif
    //sprintf(GPSDB_str,"0   dB");
    UxCtrl_SetShow(&UIFlowWndMovie_GPSDBCtrl,FALSE);
    UxStatic_SetData(&UIFlowWndMovie_GPSDBCtrl,STATIC_VALUE,Txt_Pointer(GPSDB_str));
    if((IsNeedToShowGPSSignal==TRUE)&&(abs(SAT_SIGNAL[0]  - 100) <= 100) && abs(SAT_SIGNAL[1]  - 100) <= 100 && abs(SAT_SIGNAL[2]  - 100) <= 100 && abs(SAT_SIGNAL[3]  - 100) <= 100)
       UxCtrl_SetShow(&UIFlowWndMovie_GPSDBCtrl,TRUE);
    else
       UxCtrl_SetShow(&UIFlowWndMovie_GPSDBCtrl,FALSE); 

      Show_RD_VolLvl(RDInfo.RD_volume);
      Show_RD_Mode(RDInfo.RD_City_Mode);
      if(RMCInfo.Status == 'A')
      Show_RD_Angle(RMCInfo.Angle);

      uiCurrentSpeed=(UINT32)(RMCInfo.Speed*1.852);
	  if(RDInfo.RD_Speed != 0)
	  {
	      Show_RD_Speed(RDInfo.RD_Speed,TRUE);
		
		  if(flag == FALSE)
	  	  {
		      UxCtrl_SetShow(&UIFlowWndMovie_CurSpeedCtrl,FALSE);
			  flag = TRUE;
		  }
	  	  else
	 	  {
	  		  UxCtrl_SetShow(&UIFlowWndMovie_CurSpeedCtrl,TRUE);	
			  flag = FALSE;
	  	  }
	  }
	  else
	  {
      	  if(uiCurrentSpeed != 0)
      	  {
          	  Show_RD_Speed(uiCurrentSpeed,TRUE);
      	  }
      	  else
      	  {
         	  Show_RD_Speed(uiCurrentSpeed,FALSE);
      	  }
	  }

      
if(UI_GetData(FL_RADAR_REPORT))//if(RDInfo.RD_IS_Connect)
    UxState_SetData(&UIFlowWndMovie_Icon_RD_ONCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_RD_ON_ICON_RD_ON);
else
    UxState_SetData(&UIFlowWndMovie_Icon_RD_ONCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_RD_ON_ICON_RD_OFF);
    
    UxState_SetData(&UIFlowWndMovie_Icon_RD_EYECtrl,STATE_CURITEM,UI_GetData(FL_RADAR_ONOFF)); 

      switch(RDInfo.kind)
        {
        case  RD_WAR_NONE:
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_WaringCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_DistanceCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Speed_limit_PanelCtrl,FALSE);
            //FlowMovie_UpdateIcons(TRUE);
            if(NeedRedorwWindow)
                {
                NeedRedorwWindow = FALSE;
                Refresh_Screen_Display();
                
            //Ux_OpenWindow(&UIWndNotUseCtrl,0);
                }
            break;
        case  RD_WAR_WAR_TYPE:
            NeedRedorwWindow = TRUE;
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarHighSpeedCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarLowSpeedCtrl,FALSE);
            UxState_SetData(&UIFlowWndMovie_Panel_Warning_TypeCtrl,STATE_CURITEM,UIFlowWndMovie_Panel_Warning_Type_ICON_RADAR_JG);
            UxCtrl_SetShow(&UIFlowWndMovie_DistanceCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_Warning_TypeCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarningCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Speed_limit_PanelCtrl,TRUE);
            break;
        case  RD_WAR_SPEED_LIMIT:
            NeedRedorwWindow = TRUE;
            if(RDInfo.limitspeed <999)
                {
                if(RDInfo.limitspeed/100 >0)
                  {
                    UxState_SetData(&UIFlowWndMovie_Speed_MCtrl,STATE_CURITEM,(RDInfo.limitspeed%100)/10);
                    UxState_SetData(&UIFlowWndMovie_Speed_LCtrl,STATE_CURITEM,(RDInfo.limitspeed%10));
                    UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarHighSpeedCtrl,TRUE);
                    UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarLowSpeedCtrl,FALSE);
                   }
                else
                    {
                    UxState_SetData(&UIFlowWndMovie_Speed_LowModeHCtrl,STATE_CURITEM,RDInfo.limitspeed/10);
                    UxState_SetData(&UIFlowWndMovie_Speed_LowModeLCtrl,STATE_CURITEM,(RDInfo.limitspeed%10));
                    
                    UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarHighSpeedCtrl,FALSE);
                    UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarLowSpeedCtrl,TRUE);
                    }
                }
            UxCtrl_SetShow(&UIFlowWndMovie_DistanceCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_Warning_TypeCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarningCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Speed_limit_PanelCtrl,TRUE);
            break;
        	case  RD_WAR_DISTANCE_1:
            case  RD_WAR_DISTANCE_2:
			if(RDInfo.distance <999)
			{
				NeedRedorwWindow = TRUE;
				UxState_SetData(&UIFlowWndMovie_Distance_HCtrl,STATE_CURITEM,RDInfo.distance/100);
				UxState_SetData(&UIFlowWndMovie_Distance_MCtrl,STATE_CURITEM,(RDInfo.distance%100)/10);
				UxState_SetData(&UIFlowWndMovie_Distance_LCtrl,STATE_CURITEM,RDInfo.distance%10);
				if(RDInfo.kind == RD_WAR_DISTANCE_1)
				{
					UxState_SetData(&UIFlowWndMovie_Panel_Warning_TypeCtrl,STATE_CURITEM,UIFlowWndMovie_Panel_Warning_Type_ICON_REDLED);
				}
				
			}
            else
            {
                UxState_SetData(&UIFlowWndMovie_Panel_Warning_TypeCtrl,STATE_CURITEM,UIFlowWndMovie_Panel_Warning_Type_ICON_RD_WAR_EYE);
				//UxCtrl_SetShow(&UIFlowWndMovie_CurSpeedCtrl,TRUE);
            }
            UxCtrl_SetShow(&UIFlowWndMovie_DistanceCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_Warning_TypeCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarHighSpeedCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarLowSpeedCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarningCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Speed_limit_PanelCtrl,TRUE);
			
            break;
        case  RD_WAR_SPEEDLIMIT_AND_DISTANCE:
            NeedRedorwWindow = TRUE;
            if(RDInfo.limitspeed <999)
                {
                if(RDInfo.limitspeed/100 >0)
                    {
                    UxState_SetData(&UIFlowWndMovie_Speed_MCtrl,STATE_CURITEM,(RDInfo.limitspeed%100)/10);
                    UxState_SetData(&UIFlowWndMovie_Speed_LCtrl,STATE_CURITEM,(RDInfo.limitspeed%10));
                    UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarHighSpeedCtrl,TRUE);
                    UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarLowSpeedCtrl,FALSE);
                    }
                else
                    {
                    UxState_SetData(&UIFlowWndMovie_Speed_LowModeHCtrl,STATE_CURITEM,RDInfo.limitspeed/10);
                    UxState_SetData(&UIFlowWndMovie_Speed_LowModeLCtrl,STATE_CURITEM,(RDInfo.limitspeed%10));
                    
                    UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarHighSpeedCtrl,FALSE);
                    UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarLowSpeedCtrl,TRUE);
                    }
                }
            if(RDInfo.distance <999)
            {
            UxState_SetData(&UIFlowWndMovie_Distance_HCtrl,STATE_CURITEM,RDInfo.distance/100);
            UxState_SetData(&UIFlowWndMovie_Distance_MCtrl,STATE_CURITEM,(RDInfo.distance%100)/10);
            UxState_SetData(&UIFlowWndMovie_Distance_LCtrl,STATE_CURITEM,RDInfo.distance%10);
            }
            UxCtrl_SetShow(&UIFlowWndMovie_DistanceCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_Warning_TypeCtrl,FALSE);

            UxCtrl_SetShow(&UIFlowWndMovie_Panel_WarningCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Speed_limit_PanelCtrl,TRUE);	
            break;
        
        }

      
      switch(RDInfo.RD_band)
        {
        case RD_band_NONE:
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_WaringCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_IconCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0Ctrl,FALSE);
            //FlowMovie_UpdateIcons(TRUE);
                if(RDNeedRedorwWindow)
                {
                Refresh_Screen_Display();
            //Ux_OpenWindow(&UIWndNotUseCtrl,0);
                }
            break;
        case RD_band_KU:
            RDNeedRedorwWindow = TRUE;
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_Waring_Panel_WarningCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_WaringCtrl,TRUE);

            ShowRDSingalLvl(RDInfo.Singallvl);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_IconCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0Ctrl,TRUE);
            break;
        case RD_band_LASER:
            RDNeedRedorwWindow = TRUE;
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_Waring_Panel_WarningCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_WaringCtrl,TRUE);

            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_IconCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0Ctrl,TRUE);
            break;
        case RD_band_Strelka:
            RDNeedRedorwWindow = TRUE;
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_Waring_Panel_WarningCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_WaringCtrl,TRUE);

            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_IconCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0Ctrl,TRUE);
            break;
        case RD_band_X:
            RDNeedRedorwWindow = TRUE;
            UxState_SetData(&UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning_TypeCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning_Type_ICON_HZ_X);
            
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_Waring_Panel_WarningCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_WaringCtrl,TRUE);

            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_IconCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0Ctrl,TRUE);

            break;
        case RD_band_KA:
            RDNeedRedorwWindow = TRUE;
            UxState_SetData(&UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning_TypeCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning_Type_ICON_HZ_KA);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_Waring_Panel_WarningCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_WaringCtrl,TRUE);

            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_IconCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0Ctrl,TRUE);

            break;
        case RD_band_K:
            RDNeedRedorwWindow = TRUE;
            UxState_SetData(&UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning_TypeCtrl,STATE_CURITEM,UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning_Type_ICON_HZ_K);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_Waring_Panel_WarningCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_WaringCtrl,TRUE);

            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_IconCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0Ctrl,TRUE);

            break;
        }


}


INT32 UIFlowWndMovie_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiEvent;
    static  UINT32 counter;

    uiEvent = paramNum ? paramArray[0] : 0;

    switch(uiEvent)
    {
    case NVTEVT_05SEC_TIMER:
       
        // Motion Detect function
        //debug_msg("motion det:%d\r\n",g_uiRecordIngMotionDet);
        if (g_uiRecordIngMotionDet==TRUE)
        {
            static UINT32  uiMotionDetGo = 0;
            static UINT32  uiMotionDetStop = 0;

            if (MD_Process()==TRUE)
            {
                 uiMotionDetGo++;
                 if (uiMotionDetGo>=2)
                 {
                    uiMotionDetStop=0;
                    if (!((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM))))
                    {
                        // reset uiMotionDetGo
                        uiMotionDetGo = 0;
                        // press enter key to record video
#if (_MODEL_DSC_ == _MODEL_CARDV_)	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif
                    }
                 }
            } else {
                uiMotionDetStop++;
                if (uiMotionDetStop>=2) // 1 sec
                {
                    uiMotionDetGo=0;
                }
                if (uiMotionDetStop>=20) // 10 Sec
                {
                    uiMotionDetStop = 0;
                    switch(gMovData.State)
                    {
                      case MOV_ST_REC:
                      case MOV_ST_REC|MOV_ST_ZOOM:
                        // stop recording
                        if (FlowMovie_GetRecCurrTime() >= 1)
                        {
 				  UIFlowWndMovie_SetGsensorTrigFlag(FALSE);    
 		  		  FlowMovie_IconHideLockFile();	                        
                            FlowMovie_StopRec();
                            if ( FALSE == AE_Wait_Stable(3, 60) )
                                DBG_ERR("Motion Detection: AE do not stable\r\n");
                        }
                        break;
                    }
                }
            }
        }

        //get GPS/GSensor Data
        
        //#NT#2013/3/20#Philex Lin-begin
        
        
        //#NT#2013/3/20#Philex Lin-end
        break;

    case NVTEVT_1SEC_TIMER:
        if(ShowGPSSignalStepCnt != 0)
            {
            ShowGPSSignalTimeCnt++;
            if(ShowGPSSignalStepCnt_last != ShowGPSSignalStepCnt)
                {
                ShowGPSSignalStepCnt_last = ShowGPSSignalStepCnt;
                ShowGPSSignalTimeCnt = 0;
                }
            if(ShowGPSSignalTimeCnt >= 2)
                {
                ShowGPSSignalTimeCnt = 0;
                ShowGPSSignalStepCnt = 0;
                ShowGPSSignalStepCnt_last = 0;
                }
            }
        else
            {
            ShowGPSSignalTimeCnt = 0;
            }
        //debug_msg("^Y  sensor 2  IO:%d  \r\n",DrvSensor_Det2ndSensor());
        
        #if (GPS_FUNCTION == ENABLE)
        UIFlowWndMovie_UpdateSpeedData();
        #endif
        UIFlowWndMovie_EdogInfo();
        FlowMovie_OnTimer1SecIndex();


       
//-------------jacky lan for test-------------------	
#if 0//(FW_TEST==ENABLE)
	 // if(counter%3==0)
	  {
    	  	Ux_PostEvent(NVTEVT_EDOG_MESSAGE, 1, 'G');
	  }
	  if(counter%2==0)
	  {
    	  	Ux_PostEvent(NVTEVT_EDOG_MESSAGE, 1, 'R');
	  }	  
	  counter++;
#endif	  
/*
          if(gbGetEdogFWVersion==FALSE)
          {
			EdgoRec_PutDemandCommand('P');
	   }
	   */
//-------------jacky lan for test-------------------

        // Isiah, implement YUV merge mode of recording func.
        if(MediaRec_IsRecording() && FlowMovie_RecGetYUVMergeMode())
        {
            MEDIAREC_READYBUF_INFO readyInfo;
            IPL_IME_BUF_ADDR CurInfo;
            IPL_SLEEP_INFO Info;

            FlowMovie_RecYUVMergeCounterInc();
            if(FlowMovie_RecGetYUVMergeRecCounter() < FlowMovie_RecGetYUVMergeRecInterval())
            {
                break;
            }
            else // reset counter;
            {
                FlowMovie_RecSetYUVMergeRecCounter(0);
            }

            Info.Id = 0;
            IPL_SetCmd(IPL_SET_WAKEUP, (void *)&Info);
            IPL_WaitCmdFinish();
            // Wait until AE/AWB are stable.
            IPC_WaitVD(FALSE,IPL_ID_1);
            IPC_WaitVD(FALSE,IPL_ID_1);
            IPC_WaitVD(FALSE,IPL_ID_1);

            CurInfo.Id = IPL_ID_1;
            IPL_GetCmd(IPL_GET_IME_CUR_BUF_ADDR, (void *)&CurInfo);

            readyInfo.y = CurInfo.ImeP1.PixelAddr[0];
            readyInfo.cb = CurInfo.ImeP1.PixelAddr[1];
            //readyInfo.cr = CurInfo.ImeP1.PixelAddr[2];
            readyInfo.cr = CurInfo.ImeP1.PixelAddr[1]; // UV pack
            readyInfo.y_lot = CurInfo.ImeP1.Ch[0].LineOfs;
            readyInfo.uv_lot = CurInfo.ImeP1.Ch[1].LineOfs;
            readyInfo.uiBufID = CurInfo.ImeP1.PixelAddr[2]; // for IME ready buffer check
            MediaRec_GiveYUV(&readyInfo);

            // Wait 40 ms to ensure encode finished.
            Delay_DelayMs(40);

            Info.Id = 0;
            IPL_SetCmd(IPL_SET_SLEEP, (void *)&Info);
            IPL_WaitCmdFinish();
        }
        else if (g_PreviewStable_Record == FALSE)
        {
            if ((g_ACPlug==TRUE)&&(g_PreviewStable == TRUE))
            {
                g_PreviewStable_Record = TRUE;
#if (_MODEL_DSC_ == _MODEL_CARDV_)	     
    	     		Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS);
#else
    	     		Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#endif
            }
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_TIMER,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnACPlug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_ACPlug = TRUE;
    // start record if receiving preview stable event
    if ((g_PreviewStable == TRUE)&&(g_PreviewStable_Record == FALSE))
    {
        g_PreviewStable_Record = TRUE;
        //Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnACUnplug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_ACPlug = FALSE;
    //Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnCustom1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];

#if (_MODEL_DSC_ == _MODEL_CARDV_)
    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	    
	     if(g_bgsensor==FALSE)
	     {
		g_bgsensor = TRUE;     
	       MediaRec_SetCrash();	
		FlowMovie_IconDrawLockFile();
	     }			
	  break;
    }
#else
    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:	    
	    switch(UI_GetData(FL_LEDSET))
	    {
	        case LED_OFF:
			UI_SetData(FL_LEDSET,LED_ON);	
			GPIOMap_TurnOnWhiteLight();						
	 		break;
		 case LED_ON:
			UI_SetData(FL_LEDSET,LED_OFF);	
			GPIOMap_TurnOffWhiteLight();				 	
		 	break;
		 default:
		 	break;
	    } 	  	
        FlowMovie_IconDrawLED();		
	  break;
    }
#endif
/*
    if(SysGetFlag(FL_MOVIE_GSENSOR) !=GSENSOR_OFF)
    {
        if ( (gMovData.State == MOV_ST_REC) || (gMovData.State == MOV_ST_REC_WAIT) )
        {
            MediaRec_SetCrash();
        }
        else if(gMovData.State == MOV_ST_VIEW)
        {
            MediaRec_SetCrash();
            Ux_PostEvent(NVTEVT_KEY_UP, 1, NVTEVT_KEY_PRESS, 0, 0);
        }
        debug_err(("*********MediaRec_SetCrash1()**********\n\r"));
    }
    */
   
	return NVTEVT_CONSUME;
}
//#NT#2015/01/21#KS Hung -begin
//#NT#Fast boot recording.
INT32 UIFlowWndMovie_OnFastBootRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_FAST_BOOT_REC_FUNC_)
    static BOOL bOnceFastRec = FALSE;

    if ( (FlowMovie_GetFirstBootRecFlag() == FALSE) && (bOnceFastRec == TRUE))
    {
        return NVTEVT_CONSUME;
    }

    UIFlowWndMovie_Initparam();
    FlowMovie_StartRec();

    g_PreviewStable = TRUE;
    g_PreviewStable_Record = TRUE;

    System_OnVideoFastBootInit2();
    Display_SetEnable(LAYER_VDO1, TRUE);
    UI_UIWndDispatchMessage(TRUE);
    Ux_OpenWindow((VControl *)(&UIFlowWndMovieCtrl), 0);
    GxVideo_SetDeviceCtrl(DOUT1, DISPLAY_DEVCTRL_BACKLIGHT, TRUE);
    bOnceFastRec = TRUE;
#endif
    return NVTEVT_CONSUME;
}
//#NT#2015/01/21#KS Hung -end


INT32 UIFlowWndMovie_GsensorTrig(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
     if(g_bgsensor==FALSE)
     {
	g_bgsensor = TRUE;     
       MediaRec_SetCrash();	
	FlowMovie_IconDrawLockFile();
     }	 	
    return NVTEVT_CONSUME;
}


INT32 UIFlowWndMovie_EdogMessage(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiEvent;
    EDOG_INFO EdogInfo;

    if(SysGetFlag(FL_EDOGMODE)== EDOG_OFF)
	return;

    if(gbEdogPhaseMessageEn==FALSE)
	return;
	
    uiEvent = paramNum ? paramArray[0] : 0;

    EdgoRec_GetEdogInfo(&EdogInfo);    
    switch(uiEvent)
    {
		case 'G':
			FlowMovie_UpdateEdogInfo_G(&EdogInfo);
		break;
		case 'R':
			FlowMovie_DrawRadarStatus(&EdogInfo);
		break;
		case 'T':
			FlowMovie_UpdateGPSTime(&EdogInfo);
		break;
		case 'U':
			FlowMovie_UpgradeCode(&EdogInfo);
		break;		
		case 'E':
			FlowMovie_UpdateErrorCode(&EdogInfo);
		break;
		case 'P':
			FlowMovie_UpdateEdogMenuInfo(&EdogInfo);			
		break;	
		case 'C':
			FlowMovie_DrawEdogGPRSStatus(&EdogInfo);
		break;		
    }
    return NVTEVT_CONSUME;
}


typedef enum
{
	UIFLOW_MOVIE_TOUCH_KEY_NONE,
	UIFLOW_MOVIE_TOUCH_KEY_RECORD,				
	UIFLOW_MOVIE_TOUCH_KEY_HOME,		
	UIFLOW_MOVIE_TOUCH_KEY_AUDIO,			
	UIFLOW_MOVIE_TOUCH_KEY_SOS,
	UIFLOW_MOVIE_TOUCH_KEY_PHOTO,
	UIFLOW_MOVIE_TOUCH_KEY_SETUP,	
	UIFLOW_MOVIE_TOUCH_KEY_MAX	
}UIFLOW_MOVIE_TOUCH_KEY;
static UIFLOW_MOVIE_TOUCH_KEY uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_NONE;



INT32 UIFlowWndMovie_TP(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  UINT32 uiEvent;
    UINT32 P1,P2;
    UINT32  uiSoundMask;
  
    if(paramNum>0)
        uiEvent = paramArray[0];	
	
	switch(uiEvent)
	{
		case GESTURE_DOWN2UP://GESTURE_RIGHT2LEFT:
		    switch(gMovData.State)
		    {
		      case MOV_ST_VIEW:
		      case MOV_ST_VIEW|MOV_ST_ZOOM:
		        // mask key while changing primary mode
		        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
		        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
		        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
		        // changing primary mode
			Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PLAYBACK);				        
		        break;
		    }					
		break;			
		
		case GESTURE_UP2DOWN://GESTURE_LEFT2RIGHT:
		    switch(gMovData.State)
		    {
		      case MOV_ST_VIEW:
		      case MOV_ST_VIEW|MOV_ST_ZOOM:
		        // mask key while changing primary mode
		        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
		        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
		        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
		        // changing primary mode
			  Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PHOTO);				        
		        break;
		    }					
		break;	
 
		case GESTURE_PRESSONLY:
			P1= paramArray[1];
			P2=paramArray[2];  
		    if(TPIsOnRange(&UIFlowWndMovie_Status_ReturnCtrl,P1,P2)==TRUE)
		    	{
		    	       uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_HOME;
		       	//Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);	
		    	}		                   		   	
		break;

		case GESTURE_RELEASE:
		break;
		
		case GESTURE_CKICK:
			P1= paramArray[1];
			P2=paramArray[2];  
	            debug_msg("^G movie GESTURE_CKICK\r\n");
		    if(TPIsOnRange(&UIFlowWndMovie_Status_ReturnCtrl,P1,P2)==TRUE)
		    	{
		    	       //if(uiMovieKeyPressed==UIFLOW_MOVIE_TOUCH_KEY_HOME)
		    	       {

                                    debug_msg("^G movie gome key\r\n");
                                    switch(gMovData.State)
					{
						case MOV_ST_VIEW:
						case MOV_ST_VIEW|MOV_ST_ZOOM:
                                                debug_msg("^G movie menu key\r\n");
							Ux_OpenWindow((VControl *)(&UIFlowWndHomeCtrl), 0);
							//Ux_PostEvent(NVTEVT_KEY_MENU, 1, NVTEVT_KEY_PRESS);
							gMovData.State = MOV_ST_MENU;
  						      if (gUIMotionDetTimerID!=NULL_TIMER)
  						      {
  						        GxTimer_StopTimer(&gUIMotionDetTimerID);
  						      }
  
  						      if (g_uiDateTimerID != NULL_TIMER)
  						      {
  						        GxTimer_StopTimer(&g_uiDateTimerID);
  						      }							
						break;		
					        case MOV_ST_REC:
					        case MOV_ST_REC|MOV_ST_ZOOM: // Isiah, implement YUV merge mode of recording func.
					            if ((FlowMovie_GetRecCurrTime() >= 1) || FlowMovie_RecGetYUVMergeMode() ||
					                (SysGetFlag(FL_MOVIE_TIMELAPSE_REC) != MOVIE_TIMELAPSEREC_OFF))//(uiState == UIFlowWndMovie_Restart_Rec))
					            {
					                FlowMovie_StopRec();
					                // update ui window icon
							   UIFlowWndMovie_SetGsensorTrigFlag(FALSE);  
					                //FlowMovie_IconHideLockFile();
							  Ux_OpenWindow((VControl *)(&UIFlowWndHomeCtrl), 0);	
							  gMovData.State = MOV_ST_MENU;

							    if (g_uiDateTimerID != NULL_TIMER)
							    {
							        GxTimer_StopTimer(&g_uiDateTimerID);
							    }							  
					            }
					            break;							
					}
		    	       }
								   
		    	}
            else  if(TPIsOnRange(&UIFlowWndMovie_AudioCtrl,P1,P2)==TRUE)
		    	{
		    	       

                        	if (UI_GetData(FL_MOVIE_AUDIO) == MOVIE_AUDIO_OFF)
                        	{
                                   UI_SetData(FL_MOVIE_AUDIO,MOVIE_AUDIO_ON);
                        	    UIMovRecObj_SetData(RECMOVIE_AUD_VOLUME, RECMOVIE_AUD_ON);
                        	}
                        	else
                        	{
                                   UI_SetData(FL_MOVIE_AUDIO,MOVIE_AUDIO_OFF);
                        	    UIMovRecObj_SetData(RECMOVIE_AUD_VOLUME, RECMOVIE_AUD_OFF);
                        	}
                                FlowMovie_IconDrawAudioOnOff();
		    	       
								   
		    	}	
            #if 1
            else  if(TPIsOnRange(&UIFlowWndMovie_Radar_ModeCtrl,P1,P2)==TRUE)
		    	{
		    	       IsNeedToShowGPSSignal =!IsNeedToShowGPSSignal;
				   if(IsNeedToShowGPSSignal)
                                RD_PutCommand(RADAR_GETGPS, 1);
                               else
                                RD_PutCommand(RADAR_GETGPS, 0);
		    	}	
            else  if(TPIsOnRange(&UIFlowWndMovie_Status_RECCtrl,P1,P2)==TRUE)
		    	{
		    	       Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);	
		    	}	
            #else
            else  if(TPIsOnRange(&UIFlowWndMovie_Radar_ModeCtrl,P1,P2)==TRUE)
		    	{
		    	       if(ShowGPSSignalStepCnt == 0)
                            ShowGPSSignalStepCnt = 1;
                       debug_msg("^R  ShowGPSSignalStepCnt = %d ================\r\n",ShowGPSSignalStepCnt);
				   
		    	}	
            else  if(TPIsOnRange(&UIFlowWndMovie_Radar_VolCtrl,P1,P2)==TRUE)
		    	{
		    	       if(ShowGPSSignalStepCnt == 1)
                            ShowGPSSignalStepCnt = 2;
                       debug_msg("^R  ShowGPSSignalStepCnt = %d ================\r\n",ShowGPSSignalStepCnt);
				   
		    	}	
            else  if(TPIsOnRange(&UIFlowWndMovie_AngleCtrl,P1,P2)==TRUE)
		    	{
		    	       if(ShowGPSSignalStepCnt == 2)
		    	        {
		    	        IsNeedToShowGPSSignal =!IsNeedToShowGPSSignal;
		    	        }
                       debug_msg("^R  ShowGPSSignalStepCnt = %d   IsNeedToShowGPSSignal = %d================\r\n",ShowGPSSignalStepCnt,IsNeedToShowGPSSignal);
				   
		    	}	

            #endif
                 else  //if(TPIsOnRange(&UIFlowWndMovie_Status_RECCtrl,P1,P2)==TRUE)
		    	{
		    	    if(Sensor_CheckExtSensor())
		    	        {
		    	      debug_msg("System_OnPipSetting : %d..\r\n",PipView_GetStyle());

	                    
                            	    switch(PipView_GetStyle())
                            	    {
                            		    case PIP_STYLE_1T1F:
                                    		PipView_SetStyle(PIP_STYLE_2T2F);
                                    		break;
                                    	    case PIP_STYLE_2T2F:
                                    		PipView_SetStyle(PIP_STYLE_2T1B2S);
                                    		break;
                                    	    case PIP_STYLE_2T1B2S:
                                    		PipView_SetStyle(PIP_STYLE_1T1F);
                                    		break;
                                    	    	
                            	    }    
		    	        }

		       	
		    	}	
			
		   FlowMovie_UpdateIcons(TRUE);
				
		    uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_NONE;
		
		break;
	}	  
	

	  
	return NVTEVT_CONSUME;
}




//---------------------UIFlowWndMovie_RecPanelCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_RecPanel)
CTRL_LIST_END

//----------------------UIFlowWndMovie_RecPanelCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_RecPanel)
EVENT_END

//----------------------UIFlowWndMovie_ResolutionCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Resolution)
EVENT_END

//----------------------UIFlowWndMovie_Status_batteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_battery)
EVENT_END

//----------------------UIFlowWndMovie_Status_ReturnCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Return)
EVENT_END

//----------------------UIFlowWndMovie_Radar_ModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Radar_Mode)
EVENT_END

//----------------------UIFlowWndMovie_Radar_VolCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Radar_Vol)
EVENT_END

//----------------------UIFlowWndMovie_Radar_Vol_LvlCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Radar_Vol_Lvl)
EVENT_END

//----------------------UIFlowWndMovie_AngleCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Angle)
EVENT_END

//---------------------UIFlowWndMovie_HMSCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_HMS)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Hour_H)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Hour_L)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Dot1)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Min_H)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Min_L)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Dot2)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Sec_H)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Sec_L)
CTRL_LIST_END

//----------------------UIFlowWndMovie_HMSCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS)
EVENT_END

//----------------------UIFlowWndMovie_HMS_Hour_HCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Hour_H)
EVENT_END

//----------------------UIFlowWndMovie_HMS_Hour_LCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Hour_L)
EVENT_END

//----------------------UIFlowWndMovie_HMS_Dot1Ctrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Dot1)
EVENT_END

//----------------------UIFlowWndMovie_HMS_Min_HCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Min_H)
EVENT_END

//----------------------UIFlowWndMovie_HMS_Min_LCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Min_L)
EVENT_END

//----------------------UIFlowWndMovie_HMS_Dot2Ctrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Dot2)
EVENT_END

//----------------------UIFlowWndMovie_HMS_Sec_HCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Sec_H)
EVENT_END

//----------------------UIFlowWndMovie_HMS_Sec_LCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Sec_L)
EVENT_END

//----------------------UIFlowWndMovie_Icon_GPSCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_GPS)
EVENT_END

//---------------------UIFlowWndMovie_Icon_Speed_limit_PanelCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Icon_Speed_limit_Panel)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel_WarHighSpeed)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel_WarLowSpeed)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel_Warning)
CTRL_LIST_END

//----------------------UIFlowWndMovie_Icon_Speed_limit_PanelCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_Speed_limit_Panel)
EVENT_END

//---------------------UIFlowWndMovie_Panel_WarHighSpeedCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel_WarHighSpeed)
CTRL_LIST_ITEM(UIFlowWndMovie_Speed_H)
CTRL_LIST_ITEM(UIFlowWndMovie_Speed_M)
CTRL_LIST_ITEM(UIFlowWndMovie_Speed_L)
CTRL_LIST_END

//----------------------UIFlowWndMovie_Panel_WarHighSpeedCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel_WarHighSpeed)
EVENT_END

//----------------------UIFlowWndMovie_Speed_HCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Speed_H)
EVENT_END

//----------------------UIFlowWndMovie_Speed_MCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Speed_M)
EVENT_END

//----------------------UIFlowWndMovie_Speed_LCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Speed_L)
EVENT_END

//---------------------UIFlowWndMovie_Panel_WarLowSpeedCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel_WarLowSpeed)
CTRL_LIST_ITEM(UIFlowWndMovie_Speed_LowModeH)
CTRL_LIST_ITEM(UIFlowWndMovie_Speed_LowModeL)
CTRL_LIST_END

//----------------------UIFlowWndMovie_Panel_WarLowSpeedCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel_WarLowSpeed)
EVENT_END

//----------------------UIFlowWndMovie_Speed_LowModeHCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Speed_LowModeH)
EVENT_END

//----------------------UIFlowWndMovie_Speed_LowModeLCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Speed_LowModeL)
EVENT_END

//---------------------UIFlowWndMovie_Panel_WarningCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel_Warning)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel_Warning_Type)
CTRL_LIST_END

//----------------------UIFlowWndMovie_Panel_WarningCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel_Warning)
EVENT_END

//----------------------UIFlowWndMovie_Panel_Warning_TypeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel_Warning_Type)
EVENT_END

//---------------------UIFlowWndMovie_DistanceCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Distance)
CTRL_LIST_ITEM(UIFlowWndMovie_Distance_H)
CTRL_LIST_ITEM(UIFlowWndMovie_Distance_M)
CTRL_LIST_ITEM(UIFlowWndMovie_Distance_L)
CTRL_LIST_ITEM(UIFlowWndMovie_Distance_Uint)
CTRL_LIST_END

//----------------------UIFlowWndMovie_DistanceCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Distance)
EVENT_END

//----------------------UIFlowWndMovie_Distance_HCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Distance_H)
EVENT_END

//----------------------UIFlowWndMovie_Distance_MCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Distance_M)
EVENT_END

//----------------------UIFlowWndMovie_Distance_LCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Distance_L)
EVENT_END

//----------------------UIFlowWndMovie_Distance_UintCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Distance_Uint)
EVENT_END

//---------------------UIFlowWndMovie_CurSpeedCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_CurSpeed)
CTRL_LIST_ITEM(UIFlowWndMovie_CurSpeed_H)
CTRL_LIST_ITEM(UIFlowWndMovie_CurSpeed_M)
CTRL_LIST_ITEM(UIFlowWndMovie_CurSpeed_L)
CTRL_LIST_ITEM(UIFlowWndMovie_CurSpeed_Uint)
CTRL_LIST_END

//----------------------UIFlowWndMovie_CurSpeedCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_CurSpeed)
EVENT_END

//----------------------UIFlowWndMovie_CurSpeed_HCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_CurSpeed_H)
EVENT_END

//----------------------UIFlowWndMovie_CurSpeed_MCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_CurSpeed_M)
EVENT_END

//----------------------UIFlowWndMovie_CurSpeed_LCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_CurSpeed_L)
EVENT_END

//----------------------UIFlowWndMovie_CurSpeed_UintCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_CurSpeed_Uint)
EVENT_END

//----------------------UIFlowWndMovie_Status_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Storage)
EVENT_END

//---------------------UIFlowWndMovie_Icon_Radar_WaringCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Icon_Radar_Waring)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning)
CTRL_LIST_END

//----------------------UIFlowWndMovie_Icon_Radar_WaringCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_Radar_Waring)
EVENT_END

//---------------------UIFlowWndMovie_Icon_Radar_Waring_Panel_WarningCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning_Type)
CTRL_LIST_END

//----------------------UIFlowWndMovie_Icon_Radar_Waring_Panel_WarningCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning)
EVENT_END

//----------------------UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning_TypeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_Radar_Waring_Panel_Warning_Type)
EVENT_END

//---------------------UIFlowWndMovie_Icon_Radar_SingalLvlCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Icon_Radar_SingalLvl)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_Radar_SingalLvl_Icon)
CTRL_LIST_ITEM(UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0)
CTRL_LIST_END

//----------------------UIFlowWndMovie_Icon_Radar_SingalLvlCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_Radar_SingalLvl)
EVENT_END

//----------------------UIFlowWndMovie_Icon_Radar_SingalLvl_IconCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_Radar_SingalLvl_Icon)
EVENT_END

//---------------------UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0Ctrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0)
CTRL_LIST_ITEM(Static93)
CTRL_LIST_ITEM(Static94)
CTRL_LIST_ITEM(Static95)
CTRL_LIST_ITEM(Static95C)
CTRL_LIST_END

//----------------------UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0Ctrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_Radar_SingalLvl_Panel0)
EVENT_END

//----------------------Static93Ctrl Event---------------------------
EVENT_BEGIN(Static93)
EVENT_END

//----------------------Static94Ctrl Event---------------------------
EVENT_BEGIN(Static94)
EVENT_END

//----------------------Static95Ctrl Event---------------------------
EVENT_BEGIN(Static95)
EVENT_END

//----------------------Static95CCtrl Event---------------------------
EVENT_BEGIN(Static95C)
EVENT_END

//----------------------UIFlowWndMovie_Icon_RD_EYECtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_RD_EYE)
EVENT_END

//----------------------UIFlowWndMovie_Icon_RD_ONCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Icon_RD_ON)
EVENT_END

//----------------------UIFlowWndMovie_TXT_RECCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_TXT_REC)
EVENT_END

//----------------------UIFlowWndMovie_GPSDBCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_GPSDB)
EVENT_END

//----------------------UIFlowWndMovie_AudioCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Audio)
EVENT_END

//----------------------UIFlowWndMovie_LockCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Lock)
EVENT_END
//----------------------UIFlowWndMovie_Status_RECCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_REC)
EVENT_END

